<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Анализатор Лотереи - Графики и Технический Анализ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        :root {
            /* Основные цвета */
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --primary-color: #667eea;
            --primary-light: #f0f4ff;
            --secondary-gradient: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);

            /* Фоновые цвета */
            --bg-white: #ffffff;
            --bg-light: #f8f9fa;
            --bg-lighter: #f0f2f5;
            --bg-gray: #e0e0e0;

            /* Цвета трендов */
            --trend-hot-high: #ff4444;
            --trend-hot: #ff8800;
            --trend-stable: #888888;
            --trend-cold: #44aa44;
            --trend-cold-low: #0066cc;

            /* Цвета состояний */
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
            --secondary: #6c757d;

            /* Текстовые цвета */
            --text-primary: #333333;
            --text-secondary: #555555;
            --text-muted: #666666;
            --text-light: #ffffff;

            /* Радиусы */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 10px;
            --radius-xl: 15px;

            /* Тени */
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.15);
            --shadow-lg: 0 10px 30px rgba(0,0,0,0.2);

            /* Расстояния */
            --space-xs: 5px;
            --space-sm: 10px;
            --space-md: 15px;
            --space-lg: 20px;
            --space-xl: 25px;
            --space-2xl: 30px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--primary-gradient);
            min-height: 100vh;
            color: var(--text-primary);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--space-lg);
        }

        .header {
            text-align: center;
            margin-bottom: var(--space-2xl);
            color: var(--text-light);
        }

        .header h1 {
            font-size: 2.25em;
            margin-bottom: var(--space-sm);
            text-shadow: none;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .section-card,
        .controls {
            background: var(--bg-white);
            border-radius: var(--radius-xl);
            padding: var(--space-xl);
            margin-bottom: var(--space-2xl);
            box-shadow: var(--shadow-lg);
        }

        .section-card-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-xs);
            margin-bottom: var(--space-lg);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: var(--space-sm);
            text-align: center;
        }

        .section-card-title {
            font-size: 1.6em;
            font-weight: 700;
            color: var(--text-primary);
        }

        .section-card p,
        .controls p {
            font-size: 1em;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .section-subtitle {
            font-size: 1em;
            color: var(--text-muted);
        }

        .legend-card {
            display: flex;
            flex-direction: column;
            gap: var(--space-lg);
            margin-bottom: var(--space-lg);
            padding: var(--space-lg);
            background: linear-gradient(135deg, var(--bg-light) 0%, var(--bg-lighter) 100%);
            border-radius: var(--radius-lg);
            border: 1px solid var(--bg-gray);
            box-shadow: var(--shadow-sm);
        }

        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--space-md);
        }

        .legend-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-xs);
            padding: var(--space-sm);
            background: var(--bg-white);
            border-radius: var(--radius-md);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
        }

        .legend-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .legend-badge {
            width: 28px;
            height: 28px;
            border-radius: var(--radius-sm);
            position: relative;
        }

        .legend-badge--hot-high {
            background: var(--trend-hot-high);
        }

        .legend-badge--hot {
            background: var(--trend-hot);
        }

        .legend-badge--stable {
            background: var(--trend-stable);
        }

        .legend-badge--cold {
            background: var(--trend-cold);
        }

        .legend-badge--cold-low {
            background: var(--trend-cold-low);
        }

        .legend-pulse {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: rgba(255,255,255,0.8);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .legend-label {
            font-size: 13px;
            font-weight: 700;
            text-align: center;
        }

        .legend-label--hot-high {
            color: var(--trend-hot-high);
        }

        .legend-label--hot {
            color: var(--trend-hot);
        }

        .legend-label--stable {
            color: var(--trend-stable);
        }

        .legend-label--cold {
            color: var(--trend-cold);
        }

        .legend-label--cold-low {
            color: var(--trend-cold-low);
        }

        .legend-description {
            font-size: 11px;
            color: var(--text-muted);
            text-align: center;
        }

        .legend-info {
            padding: var(--space-sm) var(--space-md);
            background: var(--bg-white);
            border-radius: var(--radius-md);
            border-left: 4px solid var(--primary-color);
            box-shadow: var(--shadow-sm);
            font-size: 13px;
            color: var(--text-muted);
            line-height: 1.4;
        }

        .form-group {
            margin-bottom: var(--space-lg);
        }

        .form-group label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: 600;
            color: var(--text-secondary);
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--bg-lighter);
            border-radius: var(--radius-md);
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
            background: var(--primary-gradient);
            color: var(--text-light);
            border: none;
            padding: 12px var(--space-xl);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shine 0.6s ease-in-out;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn.cold-btn {
            background: linear-gradient(135deg, var(--trend-cold-low) 0%, #4488cc 100%);
        }

        .btn.secondary-btn {
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--bg-light) 100%);
            color: var(--primary-color);
        }

        .btn.secondary-btn:hover {
            color: var(--text-light);
            background: var(--primary-gradient);
        }

        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-sm);
        }

        @keyframes shine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .number-selector {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: var(--space-sm);
            margin-bottom: var(--space-lg);
        }

        .number-btn {
            padding: var(--space-md);
            border: 2px solid var(--bg-lighter);
            border-radius: var(--radius-lg);
            background: linear-gradient(135deg, var(--bg-white) 0%, var(--bg-light) 100%);
            cursor: pointer;
            text-align: center;
            font-weight: 700;
            font-size: 16px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .number-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }

        .number-btn:hover::before {
            left: 100%;
        }

        .number-btn:hover {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary-color) 100%);
            color: var(--text-light);
            transform: translateY(-3px) scale(1.05);
            box-shadow: var(--shadow-lg);
        }

        .number-btn:active {
            transform: translateY(-1px) scale(1.02);
            transition: all 0.1s;
        }

        .number-btn.active {
            background: var(--primary-color);
            color: var(--text-light);
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        /* Стили для активного уголка в кнопках таблицы */
        .corner-btn {
            position: absolute;
            top: -3px;
            right: -3px;
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            color: var(--text-light);
            border-radius: 3px;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .number-btn:hover .corner-btn {
            display: flex;
            transform: translateY(1px) scale(1.1);
            background: var(--primary-dark);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .number-btn {
            position: relative;
        }

        /* Цветовая индикация трендов для кнопок в таблице */
        .number-btn.trend-up-high {
            background: linear-gradient(135deg, var(--trend-hot-high) 0%, #ff6666 100%);
            color: var(--text-light);
            border-color: var(--trend-hot-high);
            animation: hotPulse 3s infinite;
        }

        .number-btn.trend-up-high::before {
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
        }

        .number-btn.trend-up {
            background: linear-gradient(135deg, var(--trend-hot) 0%, #ffaa44 100%);
            color: var(--text-light);
            border-color: var(--trend-hot);
        }

        .number-btn.trend-up::before {
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
        }

        .number-btn.trend-down {
            background: linear-gradient(135deg, var(--trend-cold) 0%, #66cc66 100%);
            color: var(--text-light);
            border-color: var(--trend-cold);
        }

        .number-btn.trend-down::before {
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
        }

        .number-btn.trend-down-low {
            background: linear-gradient(135deg, var(--trend-cold-low) 0%, #4488cc 100%);
            color: var(--text-light);
            border-color: var(--trend-cold-low);
            animation: coldGlow 4s infinite;
        }

        .number-btn.trend-down-low::before {
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
        }

        .number-btn.trend-stable {
            background: linear-gradient(135deg, var(--trend-stable) 0%, #aaaaaa 100%);
            color: var(--text-light);
            border-color: var(--trend-stable);
        }

        .number-btn.trend-stable::before {
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
        }

            /* Анимации для температурных состояний */
            @keyframes hotPulse {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.05); }
            }

            @keyframes coldGlow {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.05); }
            }

        @keyframes pulse {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.3; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

            /* Подсветка выбранного номера */
            .number-btn.selected-highlight {
                position: relative;
                transform: scale(1.1) !important;
                z-index: 10;
                border: 3px solid var(--primary-color) !important;
                box-shadow: 0 0 20px rgba(102, 51, 153, 0.6) !important;
                animation: selectedPulse 2s infinite !important;
            }

            @keyframes selectedPulse {
                0%, 100% { 
                    box-shadow: 0 0 20px rgba(102, 51, 153, 0.6);
                    transform: scale(1.1);
                }
                50% { 
                    box-shadow: 0 0 30px rgba(102, 51, 153, 0.8);
                    transform: scale(1.15);
                }
        }

        /* Цветовая индикация трендов для числа в характеристике */
        .number-container.trend-up-high {
            background: var(--trend-hot-high);
            color: var(--text-light);
            border-color: var(--trend-hot-high);
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.3);
        }

        .number-container.trend-up {
            background: var(--trend-hot);
            color: var(--text-light);
            border-color: var(--trend-hot);
            box-shadow: 0 0 8px rgba(255, 136, 0, 0.3);
        }

        .number-container.trend-down {
            background: var(--trend-cold);
            color: var(--text-light);
            border-color: var(--trend-cold);
            box-shadow: 0 0 8px rgba(68, 170, 68, 0.3);
        }

        .number-container.trend-down-low {
            background: var(--trend-cold-low);
            color: var(--text-light);
            border-color: var(--trend-cold-low);
            box-shadow: 0 0 10px rgba(0, 102, 204, 0.3);
        }

        .number-container.trend-stable {
            background: var(--trend-stable);
            color: var(--text-light);
            border-color: var(--trend-stable);
        }

        .chart-container {
            background: var(--bg-white);
            border-radius: var(--radius-xl);
            padding: var(--space-xl);
            margin-bottom: var(--space-2xl);
            box-shadow: var(--shadow-lg);
        }

        .chart-container h2 {
            margin-bottom: var(--space-lg);
            color: var(--text-primary);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: var(--space-sm);
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
            margin-bottom: var(--space-lg);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--space-md);
            margin-top: var(--space-lg);
        }

        .stat-card {
            background: var(--bg-light);
            padding: var(--space-md);
            border-radius: var(--radius-lg);
            text-align: center;
            border-left: 4px solid var(--primary-color);
        }

        .stat-card h3 {
            color: var(--primary-color);
            margin-bottom: var(--space-xs);
        }

        .stat-card .value {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--text-primary);
        }

        .prediction-panel {
            background: var(--secondary-gradient);
            border-radius: var(--radius-xl);
            padding: var(--space-xl);
            margin-bottom: var(--space-2xl);
            color: var(--text-primary);
        }

        .prediction-panel h2 {
            margin-bottom: var(--space-lg);
            color: var(--text-primary);
        }

        .prediction-item {
            background: var(--bg-white);
            padding: var(--space-md);
            border-radius: var(--radius-lg);
            margin-bottom: var(--space-sm);
            box-shadow: var(--shadow-sm);
        }

        .prediction-item h4 {
            color: var(--primary-color);
            margin-bottom: var(--space-xs);
        }

        .stat-portrait {
            background: var(--bg-white);
            padding: var(--space-lg);
            border-radius: var(--radius-lg);
            margin-bottom: var(--space-sm);
            box-shadow: var(--shadow-sm);
        }
        .stat-portrait h4 {
            color: var(--primary-color);
            margin-top: 0;
            margin-bottom: var(--space-md);
            font-size: 1.2em;
        }
        .stat-portrait p {
            margin: var(--space-sm) 0;
            line-height: 1.6;
            font-size: 1em;
        }

        /* Новый компактный дизайн портрета */
        .portrait-header {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .number-container {
            padding: var(--space-sm);
            border: 2px solid var(--bg-lighter);
            border-radius: var(--radius-md);
            display: inline-block;
            width: auto;
            height: auto;
            min-width: 50px;
            min-height: 50px;
            text-align: center;
            font-weight: 600;
            font-size: 1.1em;
            transition: all 0.3s;
            box-shadow: var(--shadow-sm);
            color: var(--text-light);
            cursor: pointer;
        }

        .number-container:hover {
            border-color: var(--primary-color);
            background: var(--primary-light);
        }

        .number-text {
            display: block;
        }

        .stats-container {
            margin-top: var(--space-xs);
        }

        .stats-frame {
            background: var(--bg-white);
            border: 1px solid var(--bg-lighter);
            border-radius: var(--radius-sm);
            padding: var(--space-xs) var(--space-sm);
            font-size: 1em;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .stats-frame strong {
            font-weight: 700;
            color: var(--text-primary);
            font-size: 1em;
        }


        .status-badge {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-md);
            font-weight: 600;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-icon {
            font-size: 1.2em;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .metric-card {
            background: var(--bg-gray);
            padding: var(--space-sm);
            border-radius: var(--radius-md);
            text-align: center;
        }

        .metric-label {
            font-size: 0.8em;
            color: var(--text-secondary);
            margin-bottom: var(--space-xs);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metric-value {
            font-size: 1.4em;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: var(--space-xs);
        }

        .metric-desc {
            font-size: 0.7em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: var(--space-xs);
        }

        .metric-bar {
            width: 100%;
            height: 6px;
            background: var(--bg-white);
            border-radius: 3px;
            overflow: hidden;
        }

        .metric-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .forecast-section {
            background: linear-gradient(135deg, var(--bg-gray), var(--bg-white));
            padding: var(--space-md);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-lg);
            text-align: center;
        }

        .forecast-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
            margin-bottom: var(--space-sm);
            font-weight: 600;
            color: var(--primary-color);
        }

        .forecast-icon {
            font-size: 1.2em;
        }

        .forecast-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-white);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: var(--space-xs);
        }

        .forecast-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .forecast-text {
            font-size: 0.9em;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .forecast-desc {
            font-size: 0.7em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: var(--space-xs);
        }

        .quick-stats {
            display: flex;
            justify-content: space-between;
            background: var(--bg-white);
            padding: var(--space-sm);
            border-radius: var(--radius-md);
            border-top: 2px solid var(--primary-color);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-xs);
        }

        .stat-label {
            font-size: 0.7em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--primary-color);
        }

        .stat-desc {
            font-size: 0.6em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 1px;
        }
        .activity-bar-background {
            width: 100%;
            height: 20px;
            background-color: var(--bg-gray);
            border-radius: var(--radius-lg);
            position: relative;
            margin-top: var(--space-xs);
        }
        .activity-bar-fill {
            height: 100%;
            border-radius: var(--radius-lg);
            transition: width 0.5s ease-in-out;
        }
        .activity-bar-fill.hot {
            background: linear-gradient(90deg, var(--warning), var(--trend-hot-high));
        }
        .activity-bar-fill.cold {
            background: linear-gradient(90deg, var(--info), var(--trend-cold));
        }
        .activity-bar-marker {
            position: absolute;
            left: 50%;
            top: -3px;
            bottom: -3px;
            width: 2px;
            background-color: var(--secondary);
            opacity: 0.7;
        }
        .activity-label {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-top: var(--space-xs);
            display: block;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-muted);
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: var(--space-md);
            border-radius: var(--radius-md);
            margin: var(--space-sm) 0;
            border-left: 4px solid #c62828;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .number-selector {
                grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            }
        }

        #generator-results-container {
            margin-top: var(--space-lg);
            background: var(--bg-light);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
        }
        .generator-results-title {
            font-size: 1.4em;
            color: var(--text-primary);
            margin-bottom: var(--space-md);
            border-bottom: 2px solid var(--bg-lighter);
            padding-bottom: var(--space-sm);
        }
        .combination-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--space-md);
        }
        .combination-card {
            background: var(--bg-white);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        .combination-card-title {
            font-weight: 600;
            color: var(--text-secondary);
            flex-shrink: 0;
        }
        .combination-numbers {
            display: flex;
            gap: var(--space-xs);
            flex-wrap: wrap;
        }
        .combo-number {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: var(--text-light);
            background: var(--primary-color);
            box-shadow: var(--shadow-sm);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .combo-number:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        /* Цветовые классы для трендов в комбинациях */
        .combo-number.trend-up-high {
            background: var(--trend-hot-high); /* Красный - очень горячий */
        }
        .combo-number.trend-up {
            background: var(--trend-hot); /* Оранжевый - горячий */
        }
        .combo-number.trend-stable {
            background: var(--trend-stable); /* Серый - стабильный */
        }
        .combo-number.trend-down {
            background: var(--trend-cold); /* Зеленый - холодный */
        }
        .combo-number.trend-down-low {
            background: var(--trend-cold-low); /* Синий - очень холодный */
        }
        .long-term-info {
            margin-top: var(--space-lg);
            padding: var(--space-md);
            background: var(--primary-light);
            border-left: 4px solid var(--primary-color);
            border-radius: var(--radius-md);
        }
        .long-term-info h4 {
            margin-top: 0;
            color: var(--primary-color);
        }

        /* Новый дизайн стратегий */
        .strategy-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--space-lg);
            margin-bottom: var(--space-lg);
        }

        .strategy-card {
            background: var(--bg-white);
            border-radius: var(--radius-xl);
            padding: var(--space-lg);
            box-shadow: var(--shadow-md);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .strategy-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }

        .strategy-card.selected {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--bg-white) 100%);
        }

        .strategy-header {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }

        .strategy-icon {
            font-size: 2em;
        }

        .strategy-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.2em;
        }

        .strategy-stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }

        .stat-item {
            text-align: center;
            padding: var(--space-xs);
            background: var(--bg-light);
            border-radius: var(--radius-md);
        }

        .stat-label {
            display: block;
            font-size: 0.8em;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .stat-value {
            display: block;
            font-weight: bold;
            font-size: 1.1em;
        }

        .stat-value.low { color: var(--success); }
        .stat-value.medium { color: var(--warning); }
        .stat-value.high { color: var(--danger); }

        .strategy-desc {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.9em;
            font-style: italic;
        }

        /* Дашборд эффективности */
        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
        }

        .efficiency-display {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .efficiency-meter {
            width: 150px;
            height: 20px;
            background: var(--bg-gray);
            border-radius: var(--radius-lg);
            overflow: hidden;
        }

        .meter-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--warning), var(--danger));
            transition: width 0.5s ease;
        }

        .meter-label {
            font-weight: 600;
            color: var(--text-primary);
        }

        .detailed-settings-wrapper {
            margin-top: var(--space-lg);
        }
        #detailed-settings {
            background: var(--bg-lighter);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            margin-top: var(--space-md);
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: var(--space-lg);
        }
        .settings-block {
            background: var(--bg-white);
            padding: var(--space-md);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
        }
        .settings-block h4 {
            margin-top: 0;
            margin-bottom: var(--space-lg);
            color: var(--text-primary);
            border-bottom: 1px solid var(--bg-lighter);
            padding-bottom: var(--space-sm);
        }
        .setting-item {
            margin-bottom: var(--space-md);
        }
        .setting-item label {
            display: block;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: var(--space-xs);
        }
        .setting-item input[type="range"] {
            width: 100%;
        }
        .setting-item-inline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-xs);
            width: 100%;
        }
        .setting-item-inline .small-input {
            width: 70px;
            padding: var(--space-xs);
            border: 2px solid var(--bg-lighter);
            border-radius: var(--radius-md);
        }

        /* Стиль для кастомного селекта в виде кнопки */
        .custom-select-btn {
            background: var(--primary-gradient);
            color: var(--text-light);
            border: none;
            padding: 12px 35px 12px 15px; /* Отступ справа для стрелки */
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            /* Иконка стрелки */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 1.2em;
        }

        /* Стиль для опций выпадающего списка, чтобы текст был читаемым */
        .custom-select-btn option {
            background: white;
            color: black;
        }

        /* Убираем стрелки в number input полях для пользовательской комбинации */
        #customNum1::-webkit-outer-spin-button,
        #customNum1::-webkit-inner-spin-button,
        #customNum2::-webkit-outer-spin-button,
        #customNum2::-webkit-inner-spin-button,
        #customNum3::-webkit-outer-spin-button,
        #customNum3::-webkit-inner-spin-button,
        #customNum4::-webkit-outer-spin-button,
        #customNum4::-webkit-inner-spin-button,
        #customNum5::-webkit-outer-spin-button,
        #customNum5::-webkit-inner-spin-button,
        #customNum6::-webkit-outer-spin-button,
        #customNum6::-webkit-inner-spin-button {
            -webkit-appearance: none !important;
            margin: 0 !important;
            display: none !important;
        }

        #customNum1, #customNum2, #customNum3, #customNum4, #customNum5, #customNum6 {
            -webkit-appearance: none !important; /* Для Safari и Chrome */
            -moz-appearance: textfield !important; /* Для Firefox */
            appearance: none !important; /* Стандартное свойство */
        }

        /* Цветовые классы для трендов в полях ввода комбинации */
        #customNum1.trend-up-high, #customNum2.trend-up-high, #customNum3.trend-up-high,
        #customNum4.trend-up-high, #customNum5.trend-up-high, #customNum6.trend-up-high {
            background: linear-gradient(135deg, var(--trend-hot-high) 0%, #ff6666 100%) !important;
            color: var(--text-light) !important;
            border-color: var(--trend-hot-high) !important;
        }

        #customNum1.trend-up, #customNum2.trend-up, #customNum3.trend-up,
        #customNum4.trend-up, #customNum5.trend-up, #customNum6.trend-up {
            background: linear-gradient(135deg, var(--trend-hot) 0%, #ffaa44 100%) !important;
            color: var(--text-light) !important;
            border-color: var(--trend-hot) !important;
        }

        #customNum1.trend-stable, #customNum2.trend-stable, #customNum3.trend-stable,
        #customNum4.trend-stable, #customNum5.trend-stable, #customNum6.trend-stable {
            background: linear-gradient(135deg, var(--trend-stable) 0%, #aaaaaa 100%) !important;
            color: var(--text-light) !important;
            border-color: var(--trend-stable) !important;
        }

        #customNum1.trend-down, #customNum2.trend-down, #customNum3.trend-down,
        #customNum4.trend-down, #customNum5.trend-down, #customNum6.trend-down {
            background: linear-gradient(135deg, var(--trend-cold) 0%, #66cc66 100%) !important;
            color: var(--text-light) !important;
            border-color: var(--trend-cold) !important;
        }

        #customNum1.trend-down-low, #customNum2.trend-down-low, #customNum3.trend-down-low,
        #customNum4.trend-down-low, #customNum5.trend-down-low, #customNum6.trend-down-low {
            background: linear-gradient(135deg, var(--trend-cold-low) 0%, #4488cc 100%) !important;
            color: var(--text-light) !important;
            border-color: var(--trend-cold-low) !important;
        }

        /* Убеждаемся что плейсхолдеры исчезают при фокусе */
        #customNum1:focus::placeholder,
        #customNum2:focus::placeholder,
        #customNum3:focus::placeholder,
        #customNum4:focus::placeholder,
        #customNum5:focus::placeholder,
        #customNum6:focus::placeholder {
            color: transparent !important;
        }

        /* Дополнительные правила для полного убирания стрелок */
        #customNum1::-webkit-outer-spin-button,
        #customNum1::-webkit-inner-spin-button,
        #customNum2::-webkit-outer-spin-button,
        #customNum2::-webkit-inner-spin-button,
        #customNum3::-webkit-outer-spin-button,
        #customNum3::-webkit-inner-spin-button,
        #customNum4::-webkit-outer-spin-button,
        #customNum4::-webkit-inner-spin-button,
        #customNum5::-webkit-outer-spin-button,
        #customNum5::-webkit-inner-spin-button,
        #customNum6::-webkit-outer-spin-button,
        #customNum6::-webkit-inner-spin-button {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            margin: 0;
            display: none;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Анализатор Лотереи</h1>
            <p>Графики движения номеров и технический анализ</p>
        </div>

        <div class="section-card">
            <div class="section-card-header" style="text-align: center;">
                <h2 class="section-card-title">Управление данными</h2>
            </div>
            
            <div class="form-group">
                <label for="newDate">Дата нового тиража:</label>
                <input type="date" id="newDate" required>
            </div>
            
            <div class="form-group">
                <label for="newDrawNumber">Номер тиража:</label>
                <input type="number" id="newDrawNumber" placeholder="Например: 7246" required>
            </div>
            
            <div class="form-group">
                <label for="newNumbers">Выигрышные номера (через запятую или пробел):</label>
                <input type="text" id="newNumbers" placeholder="Например: 1, 15, 23, 34, 42, 49 или 1 15 23 34 42 49" required>
            </div>
            
            <div class="action-buttons">
                <button class="btn cold-btn" onclick="addNewDraw()">Добавить тираж</button>
                <button class="btn cold-btn" onclick="loadData()">Обновить данные</button>
                <button class="btn cold-btn" onclick="toggleEditDraws()">Редактировать тиражи</button>
            </div>
        </div>

        <div id="editDrawsSection" class="section-card" style="display:none;">
            <div class="section-card-header" style="text-align: center;">
                <h2 class="section-card-title">Редактирование тиражей</h2>
            </div>
            <div id="drawsList"></div>
            <button class="btn cold-btn" onclick="toggleEditDraws()" style="margin-top: var(--space-md);">Закрыть</button>
        </div>


        <div class="section-card">
            <div class="section-card-header" style="text-align: center;">
                <h2 class="section-card-title">Выберите номер для анализа</h2>
            </div>
            
            <div class="legend-card">
                <div class="legend-grid">
                    <div class="legend-item" title="Номер выпадает значительно чаще среднего интервала">
                        <div class="legend-badge legend-badge--hot-high">
                            <span class="legend-pulse"></span>
                        </div>
                        <span class="legend-label legend-label--hot-high">Очень горячий</span>
                        <span class="legend-description">Часто выпадает</span>
                    </div>
                    <div class="legend-item" title="Номер выпадает чаще среднего интервала">
                        <div class="legend-badge legend-badge--hot"></div>
                        <span class="legend-label legend-label--hot">Горячий</span>
                        <span class="legend-description">Выше среднего</span>
                    </div>
                    <div class="legend-item" title="Номер выпадает в пределах среднего интервала">
                        <div class="legend-badge legend-badge--stable"></div>
                        <span class="legend-label legend-label--stable">Стабильный</span>
                        <span class="legend-description">Средняя частота</span>
                    </div>
                    <div class="legend-item" title="Номер выпадает реже среднего интервала">
                        <div class="legend-badge legend-badge--cold"></div>
                        <span class="legend-label legend-label--cold">Холодный</span>
                        <span class="legend-description">Ниже среднего</span>
                    </div>
                    <div class="legend-item" title="Номер выпадает значительно реже среднего интервала">
                        <div class="legend-badge legend-badge--cold-low"></div>
                        <span class="legend-label legend-label--cold-low">Очень холодный</span>
                        <span class="legend-description">Редко выпадает</span>
                    </div>
                </div>
                <div class="legend-info">
                    <strong>Температура номера</strong> — показатель активности номера за последние 20 тиражей относительно среднего уровня.
                </div>
            </div>
            
            <!-- CSS анимация для пульсации -->
            <style>
                @keyframes pulse {
                    0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    50% { opacity: 0.3; transform: translate(-50%, -50%) scale(1.2); }
                    100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                }
            </style>
            
            <div class="number-selector" id="numberSelector">
                <!-- Номера будут добавлены динамически -->
            </div>
        </section>

        <div class="chart-container" id="chartContainer" style="display: none;">
            <h2 id="chartTitle" style="text-align: center; font-size: 1.8em; font-weight: 700; color: var(--primary-color); margin-bottom: 25px; text-shadow: 1px 1px 2px rgba(0,0,0,0.1);">График номера</h2>
            <div class="chart-wrapper">
                <canvas id="numberChart"></canvas>
            </div>
            
            
            </div>

        <div class="observation-panel" id="portrait-panel" style="display: none;">
            <!-- Статистический портрет будет здесь -->
        </div>

        <!-- Раздел для пользовательской комбинации -->
        <div class="section-card" id="custom-combination-panel">
            <div class="section-card-header">
                <h2 class="section-card-title">🎲 Проверить свою комбинацию</h2>
                <p class="section-subtitle">Введите шесть чисел от 1 до 49 и получите их оценку</p>
            </div>

            <!-- Основная панель ввода -->
            <div style="background: linear-gradient(135deg, var(--bg-white) 0%, var(--bg-light) 100%); border-radius: var(--radius-lg); padding: var(--space-xl); box-shadow: var(--shadow-md); border: 1px solid var(--bg-gray); margin-bottom: var(--space-lg);">
                
                <!-- Единая строка с заголовком, полями ввода и настройками -->
                <div style="display: flex; align-items: center; gap: var(--space-lg); flex-wrap: wrap; justify-content: center;">
                    
                    <!-- Заголовок и поля ввода -->
                    <div style="display: flex; align-items: center; gap: var(--space-md);">
                        <div style="width: 35px; height: 35px; background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 18px; font-weight: bold;">🎲</div>
                        <div style="text-align: center;">
                            <h3 style="margin: 0 0 var(--space-xs) 0; font-size: 1.2em; font-weight: 700; color: var(--text-primary); white-space: nowrap;">6 чисел:</h3>
                            <span style="font-size: 13px; color: var(--text-muted);">Числа от 1 до 49</span>
                        </div>

                        <div style="display: flex; gap: var(--space-sm);">
                            <input type="text" id="customNum1" placeholder="1" style="width: 50px; height: 50px; text-align: center; font-size: 18px; font-weight: 700; border: 2px solid var(--bg-lighter); border-radius: var(--radius-md); transition: all 0.3s ease; background: var(--bg-white); box-shadow: var(--shadow-sm);"
                                   onfocus="this.style.borderColor='var(--primary-color)'; this.style.transform='scale(1.05)'"
                                   onblur="this.style.borderColor='var(--bg-lighter)'; this.style.transform='scale(1)'"
                                   oninput="this.value = this.value.replace(/[^0-9]/g, '').substring(0, 2); validateCombinationInput(this);">
                            <input type="text" id="customNum2" placeholder="2" style="width: 50px; height: 50px; text-align: center; font-size: 18px; font-weight: 700; border: 2px solid var(--bg-lighter); border-radius: var(--radius-md); transition: all 0.3s ease; background: var(--bg-white); box-shadow: var(--shadow-sm);"
                                   onfocus="this.style.borderColor='var(--primary-color)'; this.style.transform='scale(1.05)'"
                                   onblur="this.style.borderColor='var(--bg-lighter)'; this.style.transform='scale(1)'"
                                   oninput="this.value = this.value.replace(/[^0-9]/g, '').substring(0, 2); validateCombinationInput(this);">
                            <input type="text" id="customNum3" placeholder="3" style="width: 50px; height: 50px; text-align: center; font-size: 18px; font-weight: 700; border: 2px solid var(--bg-lighter); border-radius: var(--radius-md); transition: all 0.3s ease; background: var(--bg-white); box-shadow: var(--shadow-sm);"
                                   onfocus="this.style.borderColor='var(--primary-color)'; this.style.transform='scale(1.05)'"
                                   onblur="this.style.borderColor='var(--bg-lighter)'; this.style.transform='scale(1)'"
                                   oninput="this.value = this.value.replace(/[^0-9]/g, '').substring(0, 2); validateCombinationInput(this);">
                            <input type="text" id="customNum4" placeholder="4" style="width: 50px; height: 50px; text-align: center; font-size: 18px; font-weight: 700; border: 2px solid var(--bg-lighter); border-radius: var(--radius-md); transition: all 0.3s ease; background: var(--bg-white); box-shadow: var(--shadow-sm);"
                                   onfocus="this.style.borderColor='var(--primary-color)'; this.style.transform='scale(1.05)'"
                                   onblur="this.style.borderColor='var(--bg-lighter)'; this.style.transform='scale(1)'"
                                   oninput="this.value = this.value.replace(/[^0-9]/g, '').substring(0, 2); validateCombinationInput(this);">
                            <input type="text" id="customNum5" placeholder="5" style="width: 50px; height: 50px; text-align: center; font-size: 18px; font-weight: 700; border: 2px solid var(--bg-lighter); border-radius: var(--radius-md); transition: all 0.3s ease; background: var(--bg-white); box-shadow: var(--shadow-sm);"
                                   onfocus="this.style.borderColor='var(--primary-color)'; this.style.transform='scale(1.05)'"
                                   onblur="this.style.borderColor='var(--bg-lighter)'; this.style.transform='scale(1)'"
                                   oninput="this.value = this.value.replace(/[^0-9]/g, '').substring(0, 2); validateCombinationInput(this);">
                            <input type="text" id="customNum6" min="1" max="49" placeholder="6" style="width: 50px; height: 50px; text-align: center; font-size: 18px; font-weight: 700; border: 2px solid var(--bg-lighter); border-radius: var(--radius-md); transition: all 0.3s ease; background: var(--bg-white); box-shadow: var(--shadow-sm);"
                                   onfocus="this.style.borderColor='var(--primary-color)'; this.style.transform='scale(1.05)'"
                                   onblur="this.style.borderColor='var(--bg-lighter)'; this.style.transform='scale(1)'"
                                   oninput="this.value = this.value.replace(/[^0-9]/g, '').substring(0, 2); validateCombinationInput(this);">
                        </div>
                    </div>

                    <!-- Настройки и кнопка -->
                    <div style="display: flex; align-items: center; gap: var(--space-md);">

                        <!-- Кнопка анализа -->
                        <button class="btn cold-btn" onclick="testCustomCombination()" style="height: 45px; padding: 0 var(--space-lg); font-size: 16px; font-weight: 600; border-radius: var(--radius-md); background: linear-gradient(135deg, var(--trend-cold-low) 0%, #4488cc 100%); position: relative; overflow: hidden; display: flex; align-items: center;">
                            Проверить на
                        </button>

                        <!-- Настройка количества тиражей -->
                        <div style="display: flex; align-items: center; gap: var(--space-sm);">
                            <select id="customTestTirageCount" style="width: 160px; height: 45px; padding: var(--space-sm) var(--space-md); background: var(--bg-white); color: var(--text-primary); border: 2px solid var(--primary-color); border-radius: var(--radius-md); font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;"
                                    onmouseover="this.style.borderColor='var(--primary-dark)'"
                                    onmouseout="this.style.borderColor='var(--primary-color)'">
                            <option value="10">10 тиражах</option>
                            <option value="20" selected>20 тиражах</option>
                            <option value="30">30 тиражах</option>
                            <option value="50">50 тиражах</option>
                            <option value="100">100 тиражах</option>
                        </select>
                    </div>
                    </div>
                </div>
            </div>

            <!-- Контейнер для результатов -->
            <div id="custom-results-container"></div>

        </div>

        <div class="section-card" id="generator-panel">
            <div class="section-card-header">
                <h2 class="section-card-title">Выберите стратегию для генерации комбинации</h2>
            </div>

            <!-- Новый визуальный выбор стратегий -->
            <div class="strategy-selection">
                <div class="strategy-card" data-strategy="conservative" onclick="selectStrategy('conservative')">
                    <div class="strategy-header">
                        <span class="strategy-icon">🛡️</span>
                        <h3>КОНСЕРВАТИВНАЯ</h3>
                    </div>
                    <div class="strategy-stats">
                        <div class="stat-item">
                            <span class="stat-label">РИСК:</span>
                            <span class="stat-value low">НИЗКИЙ</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">ШАНС:</span>
                            <span class="stat-value">40%</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">ТЕСТ:</span>
                            <span class="stat-value high">85%</span>
                        </div>
                    </div>
                    <div class="strategy-desc">Стабильные номера с низкой волатильностью</div>
        </div>

                <div class="strategy-card" data-strategy="balanced" onclick="selectStrategy('balanced')">
                    <div class="strategy-header">
                        <span class="strategy-icon">⚖️</span>
                        <h3>СБАЛАНСИРОВАННАЯ</h3>
                        </div>
                    <div class="strategy-stats">
                        <div class="stat-item">
                            <span class="stat-label">РИСК:</span>
                            <span class="stat-value medium">СРЕДНИЙ</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">ШАНС:</span>
                            <span class="stat-value">60%</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">ТЕСТ:</span>
                            <span class="stat-value high">78%</span>
                        </div>
                        </div>
                    <div class="strategy-desc">Лучший баланс риска и шанса для регулярной игры</div>
                    </div>

                <div class="strategy-card" data-strategy="ai" onclick="selectStrategy('ai')">
                    <div class="strategy-header">
                        <span class="strategy-icon">🤖</span>
                        <h3>ИИ-ПРЕДСКАЗАНИЕ</h3>
                        </div>
                    <div class="strategy-stats">
                        <div class="stat-item">
                            <span class="stat-label">РИСК:</span>
                            <span class="stat-value medium">СРЕДНИЙ</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">ШАНС:</span>
                            <span class="stat-value">85%</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">ТЕСТ:</span>
                            <span class="stat-value high">92%</span>
                        </div>
                    </div>
                    <div class="strategy-desc">Самообучающийся ИИ на основе полной статистики</div>
                        </div>
                    </div>


            <!-- Этот блок будет скрыт -->
            <div id="strategy-dashboard" style="display: none !important;"></div>

            <!-- Новый блок для кнопки и селектора -->
            <div id="generation-controls" style="display: flex; margin-top: 20px; align-items: center; gap: 15px; flex-wrap: wrap;">
                <button class="btn cold-btn" id="generate-btn" onclick="generateSelectedStrategy()" style="height: 40px; padding: 0 20px; font-size: 14px; background: linear-gradient(135deg, var(--trend-cold-low) 0%, #4488cc 100%); position: relative; overflow: hidden;">
                    🚀 СГЕНЕРИРОВАТЬ КОМБИНАЦИИ
                </button>

                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="testTirageCount" style="font-weight: 600; color: var(--text-secondary); font-size: 14px; white-space: nowrap;">Тест на тиражах:</label>
                    <select id="testTirageCount" onchange="updateQuickSummary()" style="width: 180px; height: 40px; padding: 8px 12px; background: var(--bg-white); color: var(--text-primary); border: 2px solid var(--primary-color); border-radius: var(--radius-md); font-size: 14px; font-weight: 600; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url('data:image/svg+xml,%3Csvg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;%23667eea&quot;%3E%3Cpath d=&quot;M7 10l5 5 5-5z&quot;/%3E%3C/svg%3E'); background-repeat: no-repeat; background-position: right 10px center; background-size: 1.2em;">
                        <option value="10">10 тиражах</option>
                        <option value="20" selected>20 тиражах</option>
                        <option value="30">30 тиражах</option>
                        <option value="50">50 тиражах</option>
                        <option value="100">100 тиражах</option>
                </select>
                    </div>

                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="numCombinations" style="font-weight: 600; color: var(--text-secondary); font-size: 14px; white-space: nowrap;">Количество комбинаций:</label>
                    <input type="number" id="numCombinations" value="8" min="1" max="50" style="width: 80px; height: 40px; padding: 8px 12px; background: var(--bg-white); color: var(--text-primary); border: 2px solid var(--primary-color); border-radius: var(--radius-md); font-size: 14px; font-weight: 600; text-align: center;">
            </div>
        </div>

            <div id="generator-results-container"></div>


    </div>

    <script>
        // Глобальные переменные
        let lottoData = null;
        let currentChart = null;
        let selectedNumber = null;
        let selectedStrategy = null;

        // Переменные для хранения сгенерированных комбинаций
        window.lastGeneratedCombinations = null;
        window.lastGeneratedStrategy = null;

        // ===============================================================================================
        // ТЕСТОВЫЕ ФУНКЦИИ
        // ===============================================================================================

        // Тестовая функция для проверки analyzeClusterBehavior
        window.testClusterBehavior = function() {
            console.log('Тестирование analyzeClusterBehavior...');
            const clusterBonuses = analyzeClusterBehavior(lottoData);
            console.log('Результат:', Object.keys(clusterBonuses).length, 'номеров с бонусами');
            return clusterBonuses;
        };

        // Тестовая функция для проверки getSmartTargetNumbers
        window.testSmartTargets = function() {
            console.log('Тестирование getSmartTargetNumbers...');
            const targets = getSmartTargetNumbers(15, lottoData);
            console.log('Топ-10 целей:', targets.slice(0, 10));
            return targets;
        };

        // Инициализация
        document.addEventListener('DOMContentLoaded', function() {
            createNumberSelector();
            loadData();
            updateNumberTrends();


            // Добавляем обработчик изменения количества комбинаций
            document.getElementById('numCombinations').addEventListener('change', function() {
                // Автоматически обновляем эффективность при изменении количества комбинаций
                updateStrategyCardsEfficiency();
            });

            // Добавляем обработчики для валидации и обновления стиля полей комбинации при вводе
            for (let i = 1; i <= 6; i++) {
                const inputField = document.getElementById(`customNum${i}`);
                inputField.addEventListener('blur', function() {
                    validateCombinationInput(this);
                });
            }
        });

        // Создание селектора номеров
        function createNumberSelector() {
            const selector = document.getElementById('numberSelector');
            for (let i = 1; i <= 49; i++) {
                const btn = document.createElement('div');
                btn.className = 'number-btn';
                btn.textContent = i;
                btn.onclick = () => selectNumber(i);

                // Добавляем активный уголок для добавления числа в комбинацию
                const cornerBtn = document.createElement('div');
                cornerBtn.className = 'corner-btn';
                cornerBtn.innerHTML = '▼';
                cornerBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addNumberToCombination(i);
                });
                btn.appendChild(cornerBtn);

                selector.appendChild(btn);
            }
        }

        // Функция добавления числа в комбинацию
        function addNumberToCombination(number) {
            // Проверяем, не повторяется ли число в комбинации
            if (isNumberInCombination(number)) {
                showError(`Число ${number} уже есть в комбинации! В лотерее числа не повторяются.`);
                return;
            }

            // Находим первое пустое поле комбинации
            for (let i = 1; i <= 6; i++) {
                const inputField = document.getElementById(`customNum${i}`);
                if (!inputField.value.trim()) {
                    inputField.value = number;

                    // Добавляем визуальный эффект добавления числа
                    inputField.style.transform = 'scale(1.1)';
                    inputField.style.borderColor = 'var(--primary-color)';
                    inputField.style.boxShadow = '0 0 10px rgba(102, 51, 153, 0.3)';

                    setTimeout(() => {
                        inputField.style.transform = 'scale(1)';
                        inputField.style.borderColor = 'var(--bg-lighter)';
                        inputField.style.boxShadow = 'var(--shadow-sm)';
                    }, 300);

                    // Обновляем стили для цветовой индикации трендов
                    updateCombinationFieldStyles();

                    showSuccess(`Число ${number} добавлено в комбинацию`);
                    return;
                }
            }

            // Если все поля заполнены, показываем сообщение
            showSuccess('Все поля комбинации заполнены. Очистите поля для добавления новых чисел.');
        }

        // Функция проверки наличия числа в комбинации
        function isNumberInCombination(number) {
            for (let i = 1; i <= 6; i++) {
                const inputField = document.getElementById(`customNum${i}`);
                const existingNumber = parseInt(inputField.value.trim());
                if (existingNumber === number) {
                    return true;
                }
            }
            return false;
        }

        // Функция валидации при вводе в поля комбинации
        function validateCombinationInput(inputField) {
            const number = parseInt(inputField.value.trim());

            // Проверяем, является ли введенное значение числом
            if (inputField.value.trim() && (isNaN(number) || number < 1 || number > 49)) {
                showError('Введите число от 1 до 49');
                inputField.value = '';
                inputField.focus();
                return;
            }

            // Проверяем на дубликаты только если поле не пустое и число корректное
            if (number && number >= 1 && number <= 49) {
                const duplicateField = findDuplicateNumberField(number, inputField);
                if (duplicateField) {
                    showError(`Число ${number} уже есть в комбинации! В лотерее числа не повторяются.`);
                    inputField.value = '';
                    inputField.focus();
                    return;
                }
            }

            // Обновляем стили после валидации
            updateCombinationFieldStyles();
        }

        // Функция поиска поля с дублирующимся числом
        function findDuplicateNumberField(number, excludeField) {
            for (let i = 1; i <= 6; i++) {
                const field = document.getElementById(`customNum${i}`);
                if (field !== excludeField && field.value.trim()) {
                    const existingNumber = parseInt(field.value.trim());
                    if (existingNumber === number) {
                        return field;
                    }
                }
            }
            return null;
        }


        // Функция проверки, является ли текущее поле пустым
        function isCurrentFieldEmpty(inputField) {
            return !inputField.value.trim();
        }


        // Функция обновления стиля полей комбинации на основе трендов
        function updateCombinationFieldStyles() {
            for (let i = 1; i <= 6; i++) {
                const inputField = document.getElementById(`customNum${i}`);
                const number = parseInt(inputField.value.trim());

                if (number && number >= 1 && number <= 49) {
                    const trend = calculateNumberTrend(number);
                    const trendClass = getTrendClass(trend.status);

                    // Убираем все классы трендов
                    inputField.classList.remove('trend-up-high', 'trend-up', 'trend-stable', 'trend-down', 'trend-down-low');

                    // Добавляем соответствующий класс тренда
                    if (trendClass) {
                        inputField.classList.add(trendClass);
                    }

                    // Обновляем стили для цветовой индикации
                    applyTrendStyling(inputField, trend.status);
                } else {
                    // Убираем стили трендов для пустых полей
                    inputField.classList.remove('trend-up-high', 'trend-up', 'trend-stable', 'trend-down', 'trend-down-low');
                    inputField.style.background = 'var(--bg-white)';
                    inputField.style.color = 'var(--text-primary)';
                    inputField.style.borderColor = 'var(--bg-lighter)';
                }
            }
        }

        // Функция применения стилей трендов к полю комбинации
        function applyTrendStyling(element, trendStatus) {
            switch (trendStatus) {
                case 'up-high':
                    element.style.background = 'linear-gradient(135deg, var(--trend-hot-high) 0%, #ff6666 100%)';
                    element.style.color = 'var(--text-light)';
                    element.style.borderColor = 'var(--trend-hot-high)';
                    break;
                case 'up':
                    element.style.background = 'linear-gradient(135deg, var(--trend-hot) 0%, #ffaa44 100%)';
                    element.style.color = 'var(--text-light)';
                    element.style.borderColor = 'var(--trend-hot)';
                    break;
                case 'stable':
                    element.style.background = 'linear-gradient(135deg, var(--trend-stable) 0%, #aaaaaa 100%)';
                    element.style.color = 'var(--text-light)';
                    element.style.borderColor = 'var(--trend-stable)';
                    break;
                case 'down':
                    element.style.background = 'linear-gradient(135deg, var(--trend-cold) 0%, #66cc66 100%)';
                    element.style.color = 'var(--text-light)';
                    element.style.borderColor = 'var(--trend-cold)';
                    break;
                case 'down-low':
                    element.style.background = 'linear-gradient(135deg, var(--trend-cold-low) 0%, #4488cc 100%)';
                    element.style.color = 'var(--text-light)';
                    element.style.borderColor = 'var(--trend-cold-low)';
                    break;
                default:
                    element.style.background = 'var(--bg-white)';
                    element.style.color = 'var(--text-primary)';
                    element.style.borderColor = 'var(--bg-lighter)';
            }
        }

        // Функция получения CSS класса для тренда
        function getTrendClass(trendStatus) {
            switch (trendStatus) {
                case 'up-high': return 'trend-up-high';
                case 'up': return 'trend-up';
                case 'stable': return 'trend-stable';
                case 'down': return 'trend-down';
                case 'down-low': return 'trend-down-low';
                default: return null;
            }
        }

        // Тестовая функция для проверки трендов разных чисел
        function testTrendColors() {
            console.log('🧪 ТЕСТИРОВАНИЕ ЦВЕТОВ ТРЕНДОВ ДЛЯ ПОЛЕЙ КОМБИНАЦИИ');

            // Тестируем разные числа с разными трендами
            const testNumbers = [1, 5, 10, 15, 20, 25, 30, 35, 40, 45];

            testNumbers.forEach(number => {
                const trend = calculateNumberTrend(number);
                console.log(`Число ${number}: статус = ${trend.status}, ratio = ${trend.ratio}`);

                // Создаем временное поле для тестирования
                const testInput = document.createElement('input');
                testInput.value = number;
                testInput.className = '';

                // Применяем стили
                const trendClass = getTrendClass(trend.status);
                if (trendClass) {
                    testInput.classList.add(trendClass);
                }
                applyTrendStyling(testInput, trend.status);

                console.log(`  Применен класс: ${trendClass}`);
                console.log(`  Стиль фона: ${testInput.style.background}`);
                console.log(`  Цвет текста: ${testInput.style.color}`);
                console.log('---');
            });
        }

        // Встроенные данные лотереи
        const embeddedLottoData = {
            "draws": [
                {"date": "06.09.2025", "draw_number": "7245", "numbers": [15, 26, 33, 34, 38, 44]},
                {"date": "09.09.2025", "draw_number": "7246", "numbers": [5, 12, 18, 25, 36, 42]},
                {"date": "11.09.2025", "draw_number": "7247", "numbers": [3, 14, 22, 28, 35, 49]},
                {"date": "13.09.2025", "draw_number": "7248", "numbers": [7, 16, 23, 31, 38, 44]},
                {"date": "04.09.2025", "draw_number": "7244", "numbers": [2, 15, 27, 30, 37, 47]},
                {"date": "02.09.2025", "draw_number": "7243", "numbers": [12, 13, 14, 23, 33, 36]},
                {"date": "30.08.2025", "draw_number": "7242", "numbers": [14, 30, 32, 36, 40, 46]},
                {"date": "28.08.2025", "draw_number": "7241", "numbers": [11, 14, 18, 20, 30, 41]},
                {"date": "26.08.2025", "draw_number": "7240", "numbers": [10, 18, 22, 32, 36, 45]},
                {"date": "23.08.2025", "draw_number": "7239", "numbers": [6, 8, 19, 27, 28, 30]},
                {"date": "21.08.2025", "draw_number": "7238", "numbers": [7, 12, 24, 30, 32, 46]},
                {"date": "19.08.2025", "draw_number": "7237", "numbers": [3, 13, 34, 38, 40, 43]},
                {"date": "16.08.2025", "draw_number": "7236", "numbers": [17, 21, 22, 44, 45, 46]},
                {"date": "14.08.2025", "draw_number": "7235", "numbers": [3, 6, 13, 29, 43, 46]},
                {"date": "12.08.2025", "draw_number": "7234", "numbers": [3, 10, 12, 17, 23, 25]},
                {"date": "09.08.2025", "draw_number": "7233", "numbers": [3, 9, 13, 14, 17, 36]},
                {"date": "07.08.2025", "draw_number": "7232", "numbers": [5, 9, 30, 31, 43, 49]},
                {"date": "05.08.2025", "draw_number": "7231", "numbers": [5, 12, 14, 30, 36, 37]},
                {"date": "02.08.2025", "draw_number": "7230", "numbers": [2, 18, 20, 30, 39, 47]},
                {"date": "31.07.2025", "draw_number": "7229", "numbers": [12, 24, 25, 28, 32, 37]},
                {"date": "29.07.2025", "draw_number": "7228", "numbers": [10, 32, 34, 36, 37, 39]},
                {"date": "26.07.2025", "draw_number": "7227", "numbers": [19, 20, 21, 32, 42, 43]},
                {"date": "24.07.2025", "draw_number": "7226", "numbers": [24, 25, 33, 35, 38, 43]},
                {"date": "22.07.2025", "draw_number": "7225", "numbers": [10, 28, 35, 39, 41, 46]},
                {"date": "19.07.2025", "draw_number": "7224", "numbers": [7, 11, 15, 28, 32, 33]},
                {"date": "17.07.2025", "draw_number": "7223", "numbers": [2, 13, 21, 22, 29, 35]},
                {"date": "15.07.2025", "draw_number": "7222", "numbers": [17, 20, 23, 25, 28, 49]},
                {"date": "12.07.2025", "draw_number": "7221", "numbers": [2, 12, 17, 22, 34, 43]},
                {"date": "10.07.2025", "draw_number": "7220", "numbers": [6, 11, 14, 28, 46, 48]},
                {"date": "08.07.2025", "draw_number": "7219", "numbers": [3, 5, 12, 13, 24, 38]},
                {"date": "05.07.2025", "draw_number": "7218", "numbers": [13, 15, 28, 34, 37, 41]},
                {"date": "03.07.2025", "draw_number": "7217", "numbers": [1, 8, 24, 44, 46, 49]},
                {"date": "01.07.2025", "draw_number": "7216", "numbers": [11, 21, 23, 37, 44, 49]},
                {"date": "28.06.2025", "draw_number": "7215", "numbers": [12, 22, 23, 24, 32, 47]},
                {"date": "26.06.2025", "draw_number": "7214", "numbers": [5, 19, 21, 36, 39, 41]},
                {"date": "24.06.2025", "draw_number": "7213", "numbers": [3, 4, 11, 31, 41, 47]},
                {"date": "21.06.2025", "draw_number": "7212", "numbers": [12, 24, 30, 33, 43, 46]},
                {"date": "19.06.2025", "draw_number": "7211", "numbers": [16, 19, 30, 42, 44, 49]},
                {"date": "17.06.2025", "draw_number": "7210", "numbers": [24, 28, 30, 35, 43, 45]},
                {"date": "14.06.2025", "draw_number": "7209", "numbers": [7, 8, 21, 30, 39, 47]},
                {"date": "12.06.2025", "draw_number": "7208", "numbers": [6, 13, 17, 26, 34, 42]},
                {"date": "10.06.2025", "draw_number": "7207", "numbers": [16, 19, 28, 34, 39, 42]},
                {"date": "07.06.2025", "draw_number": "7206", "numbers": [23, 34, 35, 42, 44, 49]},
                {"date": "05.06.2025", "draw_number": "7205", "numbers": [1, 17, 21, 22, 26, 31]},
                {"date": "03.06.2025", "draw_number": "7204", "numbers": [10, 11, 12, 22, 25, 36]},
                {"date": "31.05.2025", "draw_number": "7203", "numbers": [18, 21, 22, 41, 42, 45]},
                {"date": "29.05.2025", "draw_number": "7202", "numbers": [5, 11, 33, 38, 44, 46]},
                {"date": "27.05.2025", "draw_number": "7201", "numbers": [7, 10, 17, 24, 33, 35]},
                {"date": "24.05.2025", "draw_number": "7200", "numbers": [4, 5, 11, 19, 30, 43]},
                {"date": "22.05.2025", "draw_number": "7199", "numbers": [18, 32, 39, 42, 44, 45]},
                {"date": "20.05.2025", "draw_number": "7198", "numbers": [15, 20, 25, 28, 45, 49]},
                {"date": "17.05.2025", "draw_number": "7197", "numbers": [2, 5, 25, 30, 32, 49]},
                {"date": "15.05.2025", "draw_number": "7196", "numbers": [7, 8, 17, 35, 36, 46]},
                {"date": "13.05.2025", "draw_number": "7195", "numbers": [8, 16, 18, 29, 33, 40]},
                {"date": "10.05.2025", "draw_number": "7194", "numbers": [5, 6, 9, 22, 36, 37]},
                {"date": "08.05.2025", "draw_number": "7193", "numbers": [5, 8, 9, 25, 35, 38]},
                {"date": "06.05.2025", "draw_number": "7192", "numbers": [9, 20, 31, 38, 42, 48]},
                {"date": "03.05.2025", "draw_number": "7191", "numbers": [1, 2, 6, 10, 28, 37]},
                {"date": "01.05.2025", "draw_number": "7190", "numbers": [8, 22, 27, 39, 46, 49]},
                {"date": "29.04.2025", "draw_number": "7189", "numbers": [4, 20, 24, 31, 32, 48]},
                {"date": "26.04.2025", "draw_number": "7188", "numbers": [10, 11, 13, 20, 27, 49]},
                {"date": "24.04.2025", "draw_number": "7187", "numbers": [2, 5, 14, 37, 42, 43]},
                {"date": "22.04.2025", "draw_number": "7186", "numbers": [1, 19, 28, 31, 33, 38]},
                {"date": "19.04.2025", "draw_number": "7185", "numbers": [3, 4, 7, 36, 37, 38]},
                {"date": "17.04.2025", "draw_number": "7184", "numbers": [2, 10, 15, 28, 33, 49]},
                {"date": "15.04.2025", "draw_number": "7183", "numbers": [5, 15, 19, 21, 25, 26]},
                {"date": "12.04.2025", "draw_number": "7182", "numbers": [6, 11, 19, 27, 31, 49]},
                {"date": "10.04.2025", "draw_number": "7181", "numbers": [1, 22, 23, 24, 42, 44]},
                {"date": "08.04.2025", "draw_number": "7180", "numbers": [16, 23, 27, 35, 38, 44]},
                {"date": "05.04.2025", "draw_number": "7179", "numbers": [7, 21, 25, 29, 37, 39]},
                {"date": "03.04.2025", "draw_number": "7178", "numbers": [4, 5, 8, 10, 23, 44]},
                {"date": "01.04.2025", "draw_number": "7177", "numbers": [6, 15, 20, 21, 27, 40]},
                {"date": "29.03.2025", "draw_number": "7176", "numbers": [15, 25, 29, 37, 39, 41]},
                {"date": "27.03.2025", "draw_number": "7175", "numbers": [16, 17, 20, 31, 35, 45]},
                {"date": "25.03.2025", "draw_number": "7174", "numbers": [3, 5, 15, 20, 26, 36]},
                {"date": "22.03.2025", "draw_number": "7173", "numbers": [17, 19, 35, 39, 46, 48]},
                {"date": "20.03.2025", "draw_number": "7172", "numbers": [18, 22, 23, 32, 36, 39]},
                {"date": "18.03.2025", "draw_number": "7171", "numbers": [24, 25, 30, 39, 44, 46]},
                {"date": "15.03.2025", "draw_number": "7170", "numbers": [6, 11, 18, 20, 28, 34]},
                {"date": "13.03.2025", "draw_number": "7169", "numbers": [1, 14, 20, 40, 41, 43]},
                {"date": "11.03.2025", "draw_number": "7168", "numbers": [2, 9, 10, 16, 27, 49]},
                {"date": "08.03.2025", "draw_number": "7167", "numbers": [14, 20, 21, 23, 26, 49]},
                {"date": "06.03.2025", "draw_number": "7166", "numbers": [3, 10, 11, 13, 18, 33]},
                {"date": "04.03.2025", "draw_number": "7165", "numbers": [9, 18, 24, 30, 31, 48]},
                {"date": "01.03.2025", "draw_number": "7164", "numbers": [3, 7, 10, 29, 40, 46]},
                {"date": "27.02.2025", "draw_number": "7163", "numbers": [1, 6, 7, 29, 37, 38]},
                {"date": "25.02.2025", "draw_number": "7162", "numbers": [1, 3, 10, 15, 17, 44]},
                {"date": "22.02.2025", "draw_number": "7161", "numbers": [2, 5, 6, 18, 36, 39]},
                {"date": "20.02.2025", "draw_number": "7160", "numbers": [4, 7, 19, 20, 38, 46]},
                {"date": "18.02.2025", "draw_number": "7159", "numbers": [3, 5, 6, 8, 15, 42]},
                {"date": "15.02.2025", "draw_number": "7158", "numbers": [20, 22, 26, 32, 44, 45]},
                {"date": "13.02.2025", "draw_number": "7157", "numbers": [21, 30, 35, 36, 37, 38]},
                {"date": "11.02.2025", "draw_number": "7156", "numbers": [3, 17, 18, 20, 29, 30]},
                {"date": "08.02.2025", "draw_number": "7155", "numbers": [7, 10, 23, 24, 48, 49]},
                {"date": "06.02.2025", "draw_number": "7154", "numbers": [8, 10, 11, 17, 36, 46]},
                {"date": "04.02.2025", "draw_number": "7153", "numbers": [17, 19, 22, 25, 31, 38]},
                {"date": "01.02.2025", "draw_number": "7152", "numbers": [2, 3, 6, 17, 20, 30]},
                {"date": "30.01.2025", "draw_number": "7151", "numbers": [4, 16, 21, 30, 43, 49]},
                {"date": "28.01.2025", "draw_number": "7150", "numbers": [7, 8, 23, 29, 31, 43]},
                {"date": "25.01.2025", "draw_number": "7149", "numbers": [28, 30, 32, 36, 40, 48]},
                {"date": "23.01.2025", "draw_number": "7148", "numbers": [9, 12, 28, 40, 42, 45]},
                {"date": "21.01.2025", "draw_number": "7147", "numbers": [5, 12, 32, 34, 36, 39]},
                {"date": "18.01.2025", "draw_number": "7146", "numbers": [20, 30, 32, 34, 43, 48]},
                {"date": "16.01.2025", "draw_number": "7145", "numbers": [26, 28, 30, 40, 44, 49]},
                {"date": "14.01.2025", "draw_number": "7144", "numbers": [6, 10, 26, 34, 40, 43]},
                {"date": "11.01.2025", "draw_number": "7143", "numbers": [7, 11, 17, 18, 30, 36]},
                {"date": "09.01.2025", "draw_number": "7142", "numbers": [1, 11, 19, 26, 42, 44]},
                {"date": "07.01.2025", "draw_number": "7141", "numbers": [10, 11, 18, 25, 41, 46]},
                {"date": "04.01.2025", "draw_number": "7140", "numbers": [11, 19, 24, 31, 34, 45]},
                {"date": "02.01.2025", "draw_number": "7139", "numbers": [2, 12, 17, 24, 42, 43]},
                {"date": "31.12.2024", "draw_number": "7138", "numbers": [4, 12, 30, 38, 46, 48]},
                {"date": "28.12.2024", "draw_number": "7137", "numbers": [8, 10, 15, 31, 39, 48]},
                {"date": "26.12.2024", "draw_number": "7136", "numbers": [3, 9, 22, 33, 42, 43]},
                {"date": "24.12.2024", "draw_number": "7135", "numbers": [2, 4, 8, 27, 31, 48]},
                {"date": "21.12.2024", "draw_number": "7134", "numbers": [7, 13, 15, 17, 22, 41]},
                {"date": "19.12.2024", "draw_number": "7133", "numbers": [13, 20, 21, 28, 30, 35]},
                {"date": "17.12.2024", "draw_number": "7132", "numbers": [26, 28, 35, 38, 40, 49]},
                {"date": "14.12.2024", "draw_number": "7131", "numbers": [12, 15, 19, 36, 47, 49]},
                {"date": "12.12.2024", "draw_number": "7130", "numbers": [3, 17, 20, 42, 43, 46]},
                {"date": "10.12.2024", "draw_number": "7129", "numbers": [2, 23, 31, 34, 36, 39]},
                {"date": "07.12.2024", "draw_number": "7128", "numbers": [6, 8, 17, 22, 40, 41]},
                {"date": "05.12.2024", "draw_number": "7127", "numbers": [2, 15, 19, 25, 29, 34]},
                {"date": "03.12.2024", "draw_number": "7126", "numbers": [9, 11, 14, 28, 36, 48]},
                {"date": "30.11.2024", "draw_number": "7125", "numbers": [9, 13, 20, 38, 41, 49]},
                {"date": "28.11.2024", "draw_number": "7124", "numbers": [3, 10, 11, 13, 24, 40]},
                {"date": "26.11.2024", "draw_number": "7123", "numbers": [4, 6, 10, 24, 26, 44]},
                {"date": "23.11.2024", "draw_number": "7122", "numbers": [10, 16, 27, 32, 45, 49]},
                {"date": "21.11.2024", "draw_number": "7121", "numbers": [8, 14, 20, 24, 26, 40]},
                {"date": "19.11.2024", "draw_number": "7120", "numbers": [2, 12, 19, 24, 35, 38]},
                {"date": "16.11.2024", "draw_number": "7119", "numbers": [1, 7, 26, 36, 37, 40]},
                {"date": "14.11.2024", "draw_number": "7118", "numbers": [1, 20, 35, 36, 44, 47]},
                {"date": "12.11.2024", "draw_number": "7117", "numbers": [6, 12, 14, 20, 21, 38]},
                {"date": "09.11.2024", "draw_number": "7116", "numbers": [2, 12, 15, 16, 35, 40]},
                {"date": "07.11.2024", "draw_number": "7115", "numbers": [1, 11, 21, 22, 31, 41]},
                {"date": "05.11.2024", "draw_number": "7114", "numbers": [5, 6, 15, 16, 41, 48]},
                {"date": "02.11.2024", "draw_number": "7113", "numbers": [5, 13, 16, 37, 40, 43]},
                {"date": "31.10.2024", "draw_number": "7112", "numbers": [8, 10, 18, 25, 41, 48]},
                {"date": "29.10.2024", "draw_number": "7111", "numbers": [5, 14, 19, 30, 35, 39]},
                {"date": "26.10.2024", "draw_number": "7110", "numbers": [13, 18, 32, 34, 36, 39]},
                {"date": "24.10.2024", "draw_number": "7109", "numbers": [5, 17, 20, 24, 42, 44]},
                {"date": "22.10.2024", "draw_number": "7108", "numbers": [12, 17, 20, 22, 24, 44]},
                {"date": "19.10.2024", "draw_number": "7107", "numbers": [9, 10, 39, 42, 44, 45]},
                {"date": "17.10.2024", "draw_number": "7106", "numbers": [7, 22, 38, 40, 45, 48]},
                {"date": "15.10.2024", "draw_number": "7105", "numbers": [6, 9, 12, 26, 45, 46]},
                {"date": "12.10.2024", "draw_number": "7104", "numbers": [5, 10, 13, 20, 21, 28]},
                {"date": "10.10.2024", "draw_number": "7103", "numbers": [2, 6, 17, 36, 38, 41]},
                {"date": "08.10.2024", "draw_number": "7102", "numbers": [1, 14, 18, 24, 35, 45]},
                {"date": "05.10.2024", "draw_number": "7101", "numbers": [3, 15, 17, 22, 29, 48]},
                {"date": "03.10.2024", "draw_number": "7100", "numbers": [13, 14, 23, 36, 43, 48]},
                {"date": "01.10.2024", "draw_number": "7099", "numbers": [3, 6, 20, 39, 44, 45]},
                {"date": "28.09.2024", "draw_number": "7098", "numbers": [8, 12, 23, 25, 26, 47]},
                {"date": "26.09.2024", "draw_number": "7097", "numbers": [1, 2, 19, 29, 33, 41]},
                {"date": "24.09.2024", "draw_number": "7096", "numbers": [1, 2, 14, 26, 30, 49]},
                {"date": "21.09.2024", "draw_number": "7095", "numbers": [4, 5, 12, 24, 36, 39]},
                {"date": "19.09.2024", "draw_number": "7094", "numbers": [2, 6, 10, 18, 21, 22]},
                {"date": "17.09.2024", "draw_number": "7093", "numbers": [4, 5, 6, 12, 16, 45]},
                {"date": "14.09.2024", "draw_number": "7092", "numbers": [5, 11, 20, 29, 35, 44]},
                {"date": "12.09.2024", "draw_number": "7091", "numbers": [16, 23, 27, 32, 33, 37]},
                {"date": "10.09.2024", "draw_number": "7090", "numbers": [2, 10, 17, 26, 32, 37]},
                {"date": "07.09.2024", "draw_number": "7089", "numbers": [8, 21, 23, 30, 31, 43]},
                {"date": "05.09.2024", "draw_number": "7088", "numbers": [2, 4, 21, 32, 40, 49]},
                {"date": "03.09.2024", "draw_number": "7087", "numbers": [3, 11, 19, 21, 27, 44]},
                {"date": "31.08.2024", "draw_number": "7086", "numbers": [12, 14, 18, 30, 34, 38]},
                {"date": "29.08.2024", "draw_number": "7085", "numbers": [2, 13, 17, 23, 32, 41]},
                {"date": "27.08.2024", "draw_number": "7084", "numbers": [3, 15, 27, 34, 45, 46]},
                {"date": "24.08.2024", "draw_number": "7083", "numbers": [1, 6, 12, 36, 37, 49]},
                {"date": "22.08.2024", "draw_number": "7082", "numbers": [2, 3, 8, 12, 17, 21]},
                {"date": "20.08.2024", "draw_number": "7081", "numbers": [2, 17, 26, 27, 32, 40]},
                {"date": "17.08.2024", "draw_number": "7080", "numbers": [13, 16, 22, 30, 38, 44]},
                {"date": "15.08.2024", "draw_number": "7079", "numbers": [9, 17, 21, 33, 35, 37]},
                {"date": "13.08.2024", "draw_number": "7078", "numbers": [1, 13, 35, 36, 41, 47]},
                {"date": "10.08.2024", "draw_number": "7077", "numbers": [1, 17, 32, 39, 42, 43]},
                {"date": "08.08.2024", "draw_number": "7076", "numbers": [21, 26, 36, 39, 45, 49]}
            ],
            "number_data": {}
        };

        // Создаем данные по номерам из тиражей
        function createNumberData() {
            const numberData = {};
            for (let i = 1; i <= 49; i++) {
                numberData[i] = [];
            }
            
            embeddedLottoData.draws.forEach(draw => {
                draw.numbers.forEach(number => {
                    numberData[number].push({
                        date: draw.date,
                        draw_number: draw.draw_number
                    });
                });
            });
            
            return numberData;
        }

        // Сохранение данных в localStorage
        function saveData() {
            try {
                const dataToSave = {
                    draws: lottoData.draws
                };
                localStorage.setItem('lottoAnalyzerData', JSON.stringify(dataToSave));

                // Также обновляем embedded данные для синхронизации
                embeddedLottoData.draws = [...lottoData.draws];
                console.log('Данные сохранены в localStorage и обновлены в embeddedLottoData');
            } catch (error) {
                console.error('Ошибка сохранения данных:', error);
                showError('Не удалось сохранить данные. Возможно, хранилище переполнено.');
            }
        }

        // Загрузка данных
        function loadData() {
            try {
                const savedData = localStorage.getItem('lottoAnalyzerData');
                let draws;
                if (savedData) {
                    console.log('Найдены сохраненные данные в localStorage.');
                    draws = JSON.parse(savedData).draws;
                    // Синхронизируем embedded данные с localStorage
                    embeddedLottoData.draws = [...draws];
                } else {
                    console.log('Сохраненные данные не найдены, используются встроенные.');
                    draws = embeddedLottoData.draws;
                }

                // Сортировка тиражей по номеру тиража в убывающем порядке
                draws.sort((a, b) => parseInt(b.draw_number) - parseInt(a.draw_number));

                lottoData = {
                    draws: draws,
                    number_data: createNumberDataFromDraws(draws) // Используем новую функцию
                };

                // Сохраняем объединенные данные для синхронизации
                saveData();

                console.log('Данные загружены:', lottoData);

                // Обновляем эффективность стратегий на основе тестирования
                updateStrategyCardsEfficiency();

                updateNumberTrends();
            } catch (error) {
                console.error('Ошибка загрузки данных:', error);
                showError('Ошибка загрузки данных: ' + error.message);
                // В случае ошибки парсинга, загружаем встроенные данные
                lottoData = {
                    draws: embeddedLottoData.draws,
                    number_data: createNumberDataFromDraws(embeddedLottoData.draws)
                };
                // Сохраняем встроенные данные для будущих загрузок
                saveData();

                // Обновляем эффективность стратегий на основе тестирования
                updateStrategyCardsEfficiency();

                updateNumberTrends();
            }
        }

        // Новая функция для создания данных по номерам из переданного массива тиражей
        function createNumberDataFromDraws(draws) {
            const numberData = {};
            for (let i = 1; i <= 49; i++) {
                numberData[i] = [];
            }
            
            draws.forEach(draw => {
                draw.numbers.forEach(number => {
                    numberData[number].push({
                        date: draw.date,
                        draw_number: draw.draw_number
                    });
                });
            });
            
            return numberData;
        }

        // Обновление цветовой индикации номеров
        function updateNumberTrends() {
            if (!lottoData) return;

            for (let number = 1; number <= 49; number++) {
                const btn = document.querySelector(`.number-btn:nth-child(${number})`);
                if (!btn) continue;

                const trend = calculateNumberTrend(number).status;
                const trendClass = getTrendClass(trend);
                
                // Убираем все классы трендов и выделение
                btn.classList.remove('trend-up-high', 'trend-up', 'trend-stable', 'trend-down', 'trend-down-low', 'selected-highlight');
                
                // Добавляем новый класс тренда
                if (trendClass) {
                    btn.classList.add(trendClass);
                }
                
                // Добавляем подсветку для выбранного номера
                if (number === selectedNumber) {
                    btn.classList.add('selected-highlight');
                }
            }
            
        }

        // Функция для создания стилизованного номера (как в таблице)
        function createStyledNumber(number) {
            if (!lottoData || !number) return number.toString();
            
            const trend = calculateNumberTrend(number).status;
            const trendClass = getTrendClass(trend);
            
            // Определяем цвет и стиль на основе тренда
            let bgColor, textColor, boxShadow, animation = '';
            
            switch (trend) {
                case 'up-high':
                    bgColor = 'var(--trend-hot-high)';
                    textColor = 'var(--text-light)';
                    boxShadow = '0 0 15px rgba(255, 68, 68, 0.4)';
                    animation = 'animation: hotPulse 3s infinite;';
                    break;
                case 'up':
                    bgColor = 'var(--trend-hot)';
                    textColor = 'var(--text-light)';
                    boxShadow = '0 0 12px rgba(255, 136, 0, 0.4)';
                    break;
                case 'down':
                    bgColor = 'var(--trend-cold)';
                    textColor = 'var(--text-light)';
                    boxShadow = '0 0 12px rgba(68, 170, 68, 0.4)';
                    break;
                case 'down-low':
                    bgColor = 'var(--trend-cold-low)';
                    textColor = 'var(--text-light)';
                    boxShadow = '0 0 15px rgba(0, 102, 204, 0.4)';
                    animation = 'animation: coldGlow 4s infinite;';
                    break;
                default:
                    bgColor = 'var(--trend-stable)';
                    textColor = 'var(--text-light)';
                    boxShadow = '0 0 8px rgba(136, 136, 136, 0.3)';
                    break;
            }
            
            return `<span style="
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 32px;
                height: 32px;
                background: ${bgColor};
                color: ${textColor};
                border-radius: var(--radius-lg);
                font-weight: 700;
                font-size: 16px;
                box-shadow: ${boxShadow};
                ${animation}
                margin: 0 4px;
                position: relative;
                overflow: hidden;
            ">${number}</span>`;
        }

                // Расчет тренда для номера
        function calculateNumberTrend(number) {
            const numberData = lottoData.number_data[number] || [];
            if (numberData.length < 3) return { status: 'stable', ratio: 1 };

            const totalDraws = lottoData.draws.length;
            const overallFrequency = numberData.length / totalDraws;
            if (overallFrequency === 0) return { status: 'stable', ratio: 1 };

            // Вычисляем частоту в последних 20 тиражах
            const recentDraws = lottoData.draws.slice(0, Math.min(20, totalDraws));
            let recentCount = 0;
            recentDraws.forEach(draw => {
                if (draw.numbers.includes(number)) {
                    recentCount++;
                }
            });
            
            const recentFrequency = recentCount / recentDraws.length;
            const ratio = recentFrequency / overallFrequency;

            let status = 'stable';
            if (ratio > 1.8) status = 'up-high'; // Выпадает в 1.8+ раза чаще чем обычно в последние 20 тиражей
            else if (ratio > 1.3) status = 'up'; // Выпадает в 1.3+ раза чаще чем обычно в последние 20 тиражей
            else if (ratio < 0.4) status = 'down-low'; // Выпадает в 0.4 раза реже чем обычно в последние 20 тиражей
            else if (ratio < 0.7) status = 'down'; // Выпадает в 0.7 раза реже чем обычно в последние 20 тиражей

            return { status, ratio };
        }


        // RSI (Relative Strength Index) для лотереи - исправленная версия
        function calculateRSI(number, period = 14) {
            const numberData = lottoData.number_data[number] || [];
            if (numberData.length < 3) {
                return { rsi: 50, status: 'Недостаточно данных' };
            }

            // Вычисляем частоту выпадений в последних тиражах
            const recentDraws = lottoData.draws.slice(0, Math.min(period, lottoData.draws.length));
            let recentCount = 0;
            recentDraws.forEach(draw => {
                if (draw.numbers.includes(number)) recentCount++;
            });
            
            const recentFrequency = recentCount / recentDraws.length;
            const overallFrequency = numberData.length / lottoData.draws.length;
            
            // Вычисляем RSI на основе соотношения недавней и общей частоты
            let rsi;
            if (overallFrequency === 0) {
                rsi = recentFrequency > 0 ? 100 : 0;
            } else {
                const ratio = recentFrequency / overallFrequency;
                // Нормализуем в диапазон 0-100
                rsi = Math.min(100, Math.max(0, (ratio - 0.5) * 100 + 50));
            }

            // Определяем статус
            let status;
            if (rsi > 70) status = 'Очень часто выпадает (перегрет)';
            else if (rsi < 30) status = 'Очень редко выпадает (переохлажден)';
            else if (rsi > 60) status = 'Часто выпадает (горячий)';
            else if (rsi < 40) status = 'Редко выпадает (холодный)';
            else status = 'Выпадает обычно (нейтральный)';

            return { rsi: Math.round(rsi), status };
        }

        // Скользящие средние частоты - исправленная версия
        function calculateMovingAverages(number, periods = [5, 10, 20]) {
            const numberData = lottoData.number_data[number] || [];
            const results = {};

            periods.forEach(period => {
                // Берем последние N тиражей
                const recentDraws = lottoData.draws.slice(0, Math.min(period, lottoData.draws.length));
                let count = 0;
                recentDraws.forEach(draw => {
                    if (draw.numbers.includes(number)) count++;
                });
                
                const ma = count / recentDraws.length;
                const maPercent = Math.round(ma * 100);
                
                let trend;
                if (maPercent > 15) trend = 'Очень часто';
                else if (maPercent > 10) trend = 'Часто';
                else if (maPercent > 5) trend = 'Иногда';
                else if (maPercent > 0) trend = 'Редко';
                else trend = 'Не выпадал';

                results[`MA${period}`] = { 
                    value: `${maPercent}%`, 
                    trend: trend
                };
            });

            return results;
        }

        // Индикатор "долга" - сколько тиражей не выпадал - исправленная версия
        function calculateDebtIndicator(number) {
            const numberData = lottoData.number_data[number] || [];
            if (numberData.length === 0) {
                return { debt: lottoData.draws.length, status: 'Никогда не выпадал' };
            }

            // Находим ПОСЛЕДНИЙ (самый новый) тираж, где выпадал номер. Он находится в начале отсортированного массива.
            const lastAppearance = numberData[0];
            const lastDrawNumber = parseInt(lastAppearance.draw_number);
            const currentDrawNumber = parseInt(lottoData.draws[0].draw_number);
            
            const debt = currentDrawNumber - lastDrawNumber;
            
            let status;
            if (debt > 20) status = 'Очень давно не выпадал';
            else if (debt > 15) status = 'Давно не выпадал';
            else if (debt > 10) status = 'Недавно не выпадал';
            else if (debt > 5) status = 'Недавно выпадал';
            else if (debt === 0) status = 'Выпал в последнем тираже';
            else status = 'Недавно выпадал';

            return { debt, status };
        }

        // Расчет статистики промежутков между выпадениями
        function calculateGapStats(numberData) {
            if (numberData.length < 2) {
                return { avgGap: 0, cv: 0 };
            }

            const gaps = [];
            for (let i = 1; i < numberData.length; i++) {
                const gap = Math.abs(parseInt(numberData[i-1].draw_number) - parseInt(numberData[i].draw_number));
                gaps.push(gap);
            }

            const avgGap = gaps.reduce((sum, gap) => sum + gap, 0) / gaps.length;
            const variance = gaps.reduce((sum, gap) => sum + Math.pow(gap - avgGap, 2), 0) / gaps.length;
            const cv = avgGap > 0 ? Math.sqrt(variance) / avgGap : 0;

            return { avgGap: Math.round(avgGap * 10) / 10, cv: Math.round(cv * 100) / 100 };
        }

        

        // Анализ трендовых линий
        function analyzeTrendLines(number) {
            const recentDraws = lottoData.draws.slice(0, 20);
            const frequencies = [];
            
            // Вычисляем частоту для каждого окна из 5 тиражей
            for (let i = 0; i < recentDraws.length - 4; i++) {
                const window = recentDraws.slice(i, i + 5);
                let count = 0;
                window.forEach(draw => {
                    if (draw.numbers.includes(number)) count++;
                });
                frequencies.push(count / 5);
            }

            if (frequencies.length < 3) return null;

            // Определяем тренд
            const first = frequencies[0];
            const middle = frequencies[Math.floor(frequencies.length / 2)];
            const last = frequencies[frequencies.length - 1];

            if (first < middle && middle < last) {
                return {
                    name: '📈 Восходящий тренд',
                    description: 'Частота выпадений растет',
                    signal: 'Продолжение роста вероятно',
                    color: '#4caf50'
                };
            } else if (first > middle && middle > last) {
                return {
                    name: '📉 Нисходящий тренд',
                    description: 'Частота выпадений падает',
                    signal: 'Продолжение падения вероятно',
                    color: '#f44336'
                };
            }

            return null;
        }

        // Анализ пиков и впадин (исправленная логика)
        function analyzePeaksAndValleys(number) {
            const recentDraws = lottoData.draws.slice(0, 20);
            const frequencies = [];
            
            // Анализируем частоту в окнах по 5 тиражей
            for (let i = 0; i < recentDraws.length - 4; i++) {
                const window = recentDraws.slice(i, i + 5);
                let count = 0;
                window.forEach(draw => {
                    if (draw.numbers.includes(number)) count++;
                });
                frequencies.push(count); // Сохраняем количество выпадений, а не процент
            }

            if (frequencies.length < 5) return null;

            // Ищем пики и впадины
            const maxCount = Math.max(...frequencies);
            const minCount = Math.min(...frequencies);
            const avgCount = frequencies.reduce((a, b) => a + b, 0) / frequencies.length;

            // Пик: если в каком-то окне выпал 4-5 раз из 5
            if (maxCount >= 4) {
                return {
                    name: '🔺 Пик частоты',
                    description: `Максимальная частота: ${maxCount}/5 тиражей (${(maxCount/5*100).toFixed(1)}%)`,
                    signal: 'Возможен откат (снижение частоты)',
                    color: '#ff9800'
                };
            }
            // Впадина: если в каком-то окне выпал 0-1 раз из 5
            else if (minCount <= 1 && avgCount < 2) {
                return {
                    name: '🔻 Впадина частоты',
                    description: `Минимальная частота: ${minCount}/5 тиражей (${(minCount/5*100).toFixed(1)}%)`,
                    signal: 'Возможен отскок (рост частоты)',
                    color: '#2196f3'
                };
            }

            return null;
        }

        // Анализ пробоев (исправленная логика)
        function analyzeBreakouts(number) {
            const numberData = lottoData.number_data[number] || [];
            if (numberData.length < 10) return null;

            const overallFrequency = numberData.length / lottoData.draws.length;
            const recentDraws = lottoData.draws.slice(0, 10);
            let recentCount = 0;
            recentDraws.forEach(draw => {
                if (draw.numbers.includes(number)) recentCount++;
            });
            const recentFrequency = recentCount / recentDraws.length;

            // Пробой вверх: если в последних 10 тиражах выпал в 6+ тиражах (60%+)
            if (recentCount >= 6) {
                return {
                    name: '🚀 Пробой вверх',
                    description: `Недавняя частота: ${recentCount}/10 тиражей (${(recentFrequency * 100).toFixed(1)}%) vs обычная: ${(overallFrequency * 100).toFixed(1)}%`,
                    signal: 'Сильный рост активности',
                    color: '#4caf50'
                };
            }
            // Пробой вниз: если в последних 10 тиражах выпал в 1-2 тиражах (20%-)
            else if (recentCount <= 2) {
                return {
                    name: '💥 Пробой вниз',
                    description: `Недавняя частота: ${recentCount}/10 тиражей (${(recentFrequency * 100).toFixed(1)}%) vs обычная: ${(overallFrequency * 100).toFixed(1)}%`,
                    signal: 'Сильное снижение активности',
                    color: '#f44336'
                };
            }

            return null;
        }

        // Анализ консолидации
        function analyzeConsolidation(number) {
            const recentDraws = lottoData.draws.slice(0, 15);
            const frequencies = [];
            
            for (let i = 0; i < recentDraws.length - 4; i++) {
                const window = recentDraws.slice(i, i + 5);
                let count = 0;
                window.forEach(draw => {
                    if (draw.numbers.includes(number)) count++;
                });
                frequencies.push(count / 5);
            }

            if (frequencies.length < 3) return null;

            // Проверяем стабильность
            const avgFreq = frequencies.reduce((a, b) => a + b, 0) / frequencies.length;
            const variance = frequencies.reduce((sum, freq) => sum + Math.pow(freq - avgFreq, 2), 0) / frequencies.length;
            const stdDev = Math.sqrt(variance);

            if (stdDev < avgFreq * 0.2) {
                return {
                    name: '📊 Консолидация',
                    description: `Стабильная частота: ${(avgFreq * 100).toFixed(1)}% ± ${(stdDev * 100).toFixed(1)}%`,
                    signal: 'Ожидание пробоя в любую сторону',
                    color: '#9c27b0'
                };
            }

            return null;
        }

        // Выбор номера для анализа
        function selectNumber(number) {
            // Если кликнули на уже выбранное число - скрываем статистику
            if (selectedNumber === number) {
                hideChart();
                selectedNumber = null;
                return;
            }

            // Обновляем активную кнопку
            document.querySelectorAll('.number-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const targetBtn = document.querySelector(`.number-btn:nth-child(${number})`);
            if (targetBtn) {
                targetBtn.classList.add('active');
            }

            selectedNumber = number;
            updateNumberTrends(); // Обновляем подсветку выбранного номера
            updateChart();
        }

        // Выбор номера из генератора комбинаций
        function selectNumberFromGenerator(number) {
            // Выбираем номер (теперь с логикой переключения)
            selectNumber(number);

            // Показываем сообщение только если статистика показана
            if (selectedNumber === number) {
                showSuccess(`Выбран номер ${number} для анализа`);
            }
        }

        // Генерация и отображение статистического портрета
        function generateAndDisplayStatisticalPortrait(number) {
            const numberData = lottoData.number_data[number] || [];
            const portraitContainer = document.getElementById('portrait-panel');
            
            if (numberData.length < 2) {
                portraitContainer.innerHTML = '<div class="stat-portrait"><h4>Статистический Портрет Номера</h4><p>Недостаточно данных для построения портрета.</p></div>';
                return;
            }

            // Получаем все данные
            const trend = calculateNumberTrend(number);
            const { debt } = calculateDebtIndicator(number);
            const { avgGap, cv } = calculateGapStats(numberData);
            const rsiData = calculateRSI(number);
            const rsi = (rsiData && rsiData.rsi !== undefined) ? rsiData.rsi : 50;

            // Определяем статус и цвет
            const getStatusInfo = () => {
            if (trend.status === 'very-hot' || trend.status === 'hot') {
                    return { text: 'ГОРЯЧИЙ', icon: '🔥', color: '#ff4444', bg: '#ffebee' };
            } else if (trend.status === 'very-cold' || trend.status === 'cold') {
                    return { text: 'ХОЛОДНЫЙ', icon: '❄️', color: '#2196f3', bg: '#e3f2fd' };
            } else {
                    return { text: 'СТАБИЛЬНЫЙ', icon: '⚖️', color: '#757575', bg: '#f5f5f5' };
                }
            };

            const statusInfo = getStatusInfo();
            const activityLevel = Math.round((trend.ratio - 1) * 100);

            // Рассчитываем вероятность выпадения
            const probability = calculateNumberProbability(number, debt, avgGap, trend.status, cv);

            // Создаем компактный визуальный портрет
            const html = `
                <div class="stat-portrait">
                    <div class="portrait-header">
                        <div class="status-badge" style="background: ${statusInfo.bg}; color: ${statusInfo.color};">
                            <span class="status-icon">${statusInfo.icon}</span>
                            <span class="status-text">${statusInfo.text}</span>
                        </div>
                        <div class="number-container ${getTrendClass(trend.status)}">
                            <span class="number-text">${number}</span>
                        </div>
                        <div class="stats-container">
                            <div class="stats-frame">
                                <strong>${numberData.length}</strong> <span style="font-weight: bold; font-size: 1em; color: #000;">выпадений</span> (за всю историю) • <span style="font-weight: bold; font-size: 1em; color: #000;">Интервал</span> <strong>${avgGap.toFixed(1)}</strong> (тиражей между выпадениями) • <span style="font-weight: bold; font-size: 1em; color: #000;">RSI</span> <strong>${rsi}</strong> (индекс силы 0-100)
                            </div>
                        </div>
                    </div>

                    <div class="metrics-grid">
                        <div class="metric-card" title="На сколько процентов номер выпадал чаще/реже среднего показателя именно в последние 20 тиражей (не за всю историю)">
                            <div class="metric-label">Активность</div>
                            <div class="metric-value">${activityLevel > 0 ? '+' : ''}${activityLevel}%</div>
                            <div class="metric-desc">За последние 20 тиражей</div>
                            <div class="metric-bar">
                                <div class="metric-fill" style="width: ${Math.min(Math.abs(activityLevel), 100)}%; background: ${activityLevel > 0 ? '#4caf50' : '#f44336'};"></div>
                            </div>
                        </div>

                        <div class="metric-card" title="Сколько тиражей прошло с момента последнего выпадения номера">
                            <div class="metric-label">Пауза</div>
                            <div class="metric-value">${debt}</div>
                            <div class="metric-desc">Текущая пауза (тиражей)</div>
                            <div class="metric-bar">
                                <div class="metric-fill" style="width: ${Math.min((debt / avgGap) * 50, 100)}%; background: ${debt > avgGap * 1.2 ? '#ff9800' : '#4caf50'};"></div>
                            </div>
                        </div>

                        <div class="metric-card" title="Насколько предсказуем ритм выпадений номера (чем ниже %, тем стабильнее)">
                            <div class="metric-label">Стабильность</div>
                            <div class="metric-value">${(cv * 100).toFixed(0)}%</div>
                            <div class="metric-desc">Коэффициент вариации</div>
                            <div class="metric-bar">
                                <div class="metric-fill" style="width: ${Math.max(100 - (cv * 100), 10)}%; background: ${cv < 0.6 ? '#4caf50' : cv < 1.0 ? '#ff9800' : '#f44336'};"></div>
                            </div>
                        </div>

                        <div class="metric-card" title="Вероятность выпадения рассчитывается на основе: текущей паузы vs среднего интервала + стабильности ритма + недавней активности">
                            <div class="metric-label">Вероятность</div>
                            <div class="metric-value">${probability.toFixed(0)}%</div>
                            <div class="metric-desc">На 5 тиражей</div>
                            <div class="metric-bar">
                                <div class="metric-fill" style="width: ${probability}%; background: ${probability > 60 ? '#4caf50' : probability > 40 ? '#ff9800' : '#f44336'};"></div>
                            </div>
                        </div>
                    </div>


                </div>
            `;

            portraitContainer.innerHTML = html;
        }

        // Расчет вероятности выпадения номера (исправленная версия)
        function calculateNumberProbability(number, debt, avgGap, status, cv) {
            if (avgGap <= 0) return 50; // Недостаточно данных

            // 1. Базовая вероятность на основе отношения паузы к среднему интервалу
            // Используем логистическую функцию для более естественного распределения
            const normalizedPause = (debt - avgGap) / avgGap; // Отклонение от среднего
            const baseProbability = 100 / (1 + Math.exp(-normalizedPause * 2)); // Логистическая функция

            // 2. Максимально усиленная корректировка по стабильности ритма
            let stabilityBonus = 0;
            if (cv < 0.6 && debt > avgGap) {
                // Стабильный ритм + пауза превысила средний интервал
                stabilityBonus = Math.min(60, (1 - cv) * 120 + (debt / avgGap - 1) * 25); // Максимально усилен бонус
            } else if (cv < 0.7 && debt > avgGap * 0.8) {
                // Хорошая стабильность + умеренная пауза
                stabilityBonus = Math.min(50, (1 - cv) * 100 + (debt / avgGap - 1) * 20);
            } else if (cv < 0.8 && debt <= avgGap) {
                // Стабильный ритм + нормальная/короткая пауза
                stabilityBonus = Math.min(40, (1 - cv) * 80 + (avgGap / debt - 1) * 15); // Усилен бонус за короткие паузы
            } else if (cv < 1.0 && debt <= avgGap) {
                // Умеренно стабильный ритм + короткая пауза
                stabilityBonus = Math.min(30, (1 - cv) * 50 + (avgGap / debt - 1) * 10); // Добавлен бонус
            } else if (cv > 1.4) {
                // Хаотичный ритм снижает предсказуемость
                stabilityBonus = -25; // Усилен штраф
            } else if (cv > 1.2) {
                // Высокая волатильность
                stabilityBonus = -15; // Усилен штраф
            }

            // 3. Корректировка по текущему статусу (меньше влияет)
            let statusAdjustment = 0;
            if (status === 'very-hot' || status === 'hot') {
                statusAdjustment = 10; // Небольшой бонус за горячую фазу
            } else if (status === 'very-cold' || status === 'cold') {
                statusAdjustment = -10; // Небольшой штраф за холодную фазу
            }

            // 4. Финальный расчёт
            const probability = Math.max(5, Math.min(95, baseProbability + stabilityBonus + statusAdjustment));

            return probability;
        }

        // Генерация практических зацепок на основе статистики
        function generatePracticalHints(number, debt, avgGap, statusText, stabilityText) {
            const hints = [];
            
            // Анализ текущего состояния
            const isHot = statusText.includes('Горячий') || statusText.includes('Очень горячий');
            const isCold = statusText.includes('Холодный') || statusText.includes('Очень холодный');
            const isStable = statusText.includes('Стабильный');
            
            // Анализ стабильности ритма
            const isStableRhythm = stabilityText.includes('Высокая') || stabilityText.includes('Средняя');
            const isChaoticRhythm = stabilityText.includes('Низкая') || stabilityText.includes('Хаотичная');
            
            // Расчет вероятности на основе текущей паузы
            const pauseRatio = avgGap > 0 ? (debt / avgGap) : 0;
            
            // Определяем основной сценарий (приоритетная логика)
            let mainScenario = '';
            let probability = 0;
            let timeFrame = '';
            let strategy = '';
            
            if (debt === 0) {
                // Номер только что выпал
                mainScenario = 'recently_appeared';
                probability = 15;
                timeFrame = '3-5 тиражей';
                strategy = 'Номер только что выпал - ожидается пауза';
            } else if (isHot && debt < 2) {
                // Горячий номер недавно выпал
                mainScenario = 'hot_recent';
                probability = 20;
                timeFrame = '3-4 тиража';
                strategy = 'Горячий номер в "перегреве" - лучше подождать остывания';
            } else if (isHot && debt >= 2 && debt < 4) {
                // Горячий номер в активной фазе
                mainScenario = 'hot_active';
                probability = 75;
                timeFrame = '2-3 тиража';
                strategy = 'Горячий номер в активной фазе - высокая вероятность';
            } else if (isCold && pauseRatio > 2.5) {
                // Холодный номер в критической точке
                mainScenario = 'cold_critical';
                probability = 65;
                timeFrame = '5-7 тиражей';
                strategy = 'Холодный номер в критической точке - оптимальное время';
            } else if (isCold && pauseRatio > 1.5) {
                // Холодный номер превысил норму
                mainScenario = 'cold_overdue';
                probability = 50;
                timeFrame = '4-6 тиражей';
                strategy = 'Холодный номер превысил норму - хорошие шансы';
            } else if (isStable && pauseRatio > 1.5) {
                // Стабильный номер превысил норму
                mainScenario = 'stable_overdue';
                probability = 55;
                timeFrame = '3-5 тиражей';
                strategy = 'Стабильный номер превысил норму - ожидается возврат';
            } else {
                // Обычное состояние
                mainScenario = 'normal';
                probability = 40;
                timeFrame = '4-6 тиражей';
                strategy = 'Номер в обычном состоянии - стандартная вероятность';
            }
            
            // Генерируем рекомендации на основе основного сценария
            switch (mainScenario) {
                case 'recently_appeared':
                    hints.push(`<p><strong>Ожидания:</strong> Номер только что выпал - следующее появление маловероятно в ближайшие ${timeFrame}</p>`);
                    hints.push(`<p><strong>Вероятность:</strong> ${probability}% в ближайшие 5 тиражей</p>`);
                    hints.push(`<p><strong>Стратегия:</strong> ${strategy}</p>`);
                    break;
                    
                case 'hot_recent':
                    hints.push(`<p><strong>Ожидания:</strong> Горячий номер недавно выпал - следующее появление маловероятно в ближайшие ${timeFrame}</p>`);
                    hints.push(`<p><strong>Вероятность:</strong> ${probability}% в ближайшие 5 тиражей</p>`);
                    hints.push(`<p><strong>Стратегия:</strong> ${strategy}</p>`);
                    break;
                    
                case 'hot_active':
                    hints.push(`<p><strong>Ожидания:</strong> Номер в "горячей фазе" - высокая вероятность появления в ближайшие ${timeFrame}</p>`);
                    hints.push(`<p><strong>Вероятность:</strong> ${probability}% в ближайшие 5 тиражей</p>`);
                    hints.push(`<p><strong>Стратегия:</strong> ${strategy}</p>`);
                    break;
                    
                case 'cold_critical':
                    hints.push(`<p><strong>Ожидания:</strong> Номер "перегрелся" от долгого отсутствия - критическая точка разворота!</p>`);
                    hints.push(`<p><strong>Временные рамки:</strong> Ожидается появление в ближайшие ${timeFrame}</p>`);
                    hints.push(`<p><strong>Вероятность:</strong> ${probability}% в ближайшие 5 тиражей</p>`);
                    hints.push(`<p><strong>Стратегия:</strong> ${strategy}</p>`);
                    if (isStableRhythm) {
                        hints.push(`<p><strong>Статистический сигнал:</strong> Стабильный номер превысил норму в ${pauseRatio.toFixed(1)} раза - сильный сигнал к появлению</p>`);
                    }
                    break;
                    
                case 'cold_overdue':
                    hints.push(`<p><strong>Ожидания:</strong> Холодный номер превысил средний интервал - ожидается возврат к норме</p>`);
                    hints.push(`<p><strong>Временные рамки:</strong> Ожидается появление в ближайшие ${timeFrame}</p>`);
                    hints.push(`<p><strong>Вероятность:</strong> ${probability}% в ближайшие 5 тиражей</p>`);
                    hints.push(`<p><strong>Стратегия:</strong> ${strategy}</p>`);
                    break;
                    
                case 'stable_overdue':
                    hints.push(`<p><strong>Ожидания:</strong> Стабильный номер превысил средний интервал - ожидается возврат к норме</p>`);
                    if (isStableRhythm) {
                        const expectedRange = Math.round(avgGap * 0.3);
                        hints.push(`<p><strong>Временные рамки:</strong> Стабильный ритм нарушен - ожидается появление в диапазоне ${Math.round(avgGap - expectedRange)}-${Math.round(avgGap + expectedRange)} тиражей</p>`);
                    } else {
                        hints.push(`<p><strong>Временные рамки:</strong> Ожидается появление в ближайшие ${timeFrame}</p>`);
                    }
                    hints.push(`<p><strong>Вероятность:</strong> ${probability}% в ближайшие 5 тиражей</p>`);
                    hints.push(`<p><strong>Стратегия:</strong> ${strategy}</p>`);
                    break;
                    
                default: // normal
                    hints.push(`<p><strong>Ожидания:</strong> Номер в обычном состоянии - стандартная вероятность появления</p>`);
                    hints.push(`<p><strong>Временные рамки:</strong> Ожидается появление в ближайшие ${timeFrame}</p>`);
                    hints.push(`<p><strong>Вероятность:</strong> ${probability}% в ближайшие 5 тиражей</p>`);
                    hints.push(`<p><strong>Стратегия:</strong> ${strategy}</p>`);
                    break;
            }
            
            return hints.join('');
        }

        // Расчет статистики по интервалам
        function calculateGapStats(numberData) {
            if (numberData.length < 2) {
                return { avgGap: 0, stdDev: 0, cv: 0 };
            }

            const gaps = [];
            for (let i = 0; i < numberData.length - 1; i++) {
                const gap = Math.abs(parseInt(numberData[i].draw_number) - parseInt(numberData[i+1].draw_number));
                gaps.push(gap);
            }

            if (gaps.length === 0) {
                return { avgGap: 0, stdDev: 0, cv: 0 };
            }

            const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
            
            const variance = gaps.reduce((sum, gap) => sum + Math.pow(gap - avgGap, 2), 0) / gaps.length;
            const stdDev = Math.sqrt(variance);
            
            const cv = avgGap > 0 ? stdDev / avgGap : 0;

            return {
                avgGap: avgGap,
                stdDev: stdDev,
                cv: cv
            };
        }

        // Новый хелпер для плавной прокрутки к графику
        function scrollToChart() {
            const chartContainer = document.getElementById('chartContainer');
            if (chartContainer && chartContainer.style.display !== 'none') {
                // Небольшая задержка, чтобы браузер успел отобразить элемент перед прокруткой
                setTimeout(() => {
                    chartContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        }

        // Обновление графика
        function updateChart() {
            if (!lottoData || !selectedNumber) return;

            const chartContainer = document.getElementById('chartContainer');
            const chartTitle = document.getElementById('chartTitle');
            const observationPanel = document.getElementById('portrait-panel');

            chartContainer.style.display = 'block';
            observationPanel.style.display = 'block';
            chartTitle.innerHTML = `График и Статистический Портрет Номера ${createStyledNumber(selectedNumber)}`;

            // Подготавливаем данные для графика
            const numberData = lottoData.number_data[selectedNumber] || [];
            const chartData = prepareChartData(numberData);
            
            // Создаем график
            createChart(chartData);
            
            // Генерируем и отображаем портрет
            generateAndDisplayStatisticalPortrait(selectedNumber);

            // Плавно прокручиваем к графику
            scrollToChart();
        }

        // Функция скрытия статистики номера
        function hideChart() {
            const chartContainer = document.getElementById('chartContainer');
            const observationPanel = document.getElementById('portrait-panel');

            if (chartContainer) {
                chartContainer.style.display = 'none';
            }
            if (observationPanel) {
                observationPanel.style.display = 'none';
            }

            // Очищаем активную кнопку
            document.querySelectorAll('.number-btn').forEach(btn => {
                btn.classList.remove('active');
            });
        }

        // Подготовка данных для графика
        function prepareChartData(numberData) {
            const labels = [];
            const data = [];
            const volumes = [];

            // Создаем временную шкалу на основе всех тиражей
            const allDraws = lottoData.draws;
            let appearanceIndex = 0;

            for (let i = 0; i < allDraws.length; i++) {
                const draw = allDraws[i];
                const date = new Date(draw.date.split('.').reverse().join('-'));
                labels.push(date);
                
                // Проверяем, выпал ли номер в этом тираже
                const appeared = draw.numbers.includes(selectedNumber);
                data.push(appeared ? 1 : 0);
                
                // Объем (количество выпадений в последних 10 тиражах)
                const recentAppearances = countRecentAppearances(selectedNumber, i, 10);
                volumes.push(recentAppearances);
            }

            return { labels, data, volumes };
        }

        // Подсчет недавних выпадений
        function countRecentAppearances(number, currentIndex, window) {
            let count = 0;
            const start = Math.max(0, currentIndex - window + 1);
            
            for (let i = start; i <= currentIndex; i++) {
                if (lottoData.draws[i].numbers.includes(number)) {
                    count++;
                }
            }
            return count;
        }

        // Создание графика
        function createChart(chartData) {
            const ctx = document.getElementById('numberChart').getContext('2d');
            
            if (currentChart) {
                currentChart.destroy();
            }

            currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        label: 'Выпадения',
                        data: chartData.data,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 6
                    }, {
                        label: 'Частота (10 тиражей)',
                        data: chartData.volumes,
                        borderColor: '#ff9a9e',
                        backgroundColor: 'rgba(255, 154, 158, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day'
                            },
                            title: {
                                display: true,
                                text: 'Дата'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Выпадение (0/1)'
                            },
                            min: -0.1,
                            max: 1.1
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Частота'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 0) {
                                        return context.parsed.y === 1 ? 'Выпал' : 'Не выпал';
                                    } else {
                                        return `Частота: ${context.parsed.y}`;
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }

        // Расчет статистики по интервалам
        function calculateGapStats(numberData) {
            if (numberData.length < 2) {
                return { avgGap: 0, stdDev: 0, cv: 0 };
            }

                const gaps = [];
            for (let i = 0; i < numberData.length - 1; i++) {
                const gap = Math.abs(parseInt(numberData[i].draw_number) - parseInt(numberData[i+1].draw_number));
                        gaps.push(gap);
                    }

            if (gaps.length === 0) {
                return { avgGap: 0, stdDev: 0, cv: 0 };
            }

            const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
            
            const variance = gaps.reduce((sum, gap) => sum + Math.pow(gap - avgGap, 2), 0) / gaps.length;
            const stdDev = Math.sqrt(variance);
            
            const cv = avgGap > 0 ? stdDev / avgGap : 0;

            return {
                avgGap: avgGap,
                stdDev: stdDev,
                cv: cv
            };
        }

        // Обновление прогнозов
        function updatePredictions(numberData) {
            const predictionsDiv = document.getElementById('predictions');
            const predictions = generatePredictions(numberData);
            
            predictionsDiv.innerHTML = predictions.map(pred => `
                <div class="prediction-item">
                    <h4>${pred.title}</h4>
                    <p>${pred.description}</p>
                    <div style="color: ${pred.color}; font-weight: bold; font-size: 1.1em;">${pred.value}</div>
                </div>
            `).join('');
        }

        // Генерация прогнозов
        function generatePredictions(numberData) {
            const predictions = [];
            const appearances = numberData.length;
            const totalDraws = lottoData.draws.length;
            
            if (appearances === 0) {
                predictions.push({
                    title: 'Номер не выпадал',
                    description: 'Этот номер еще не выпадал в истории',
                    value: 'Высокая вероятность выпадения',
                    color: '#4caf50'
                });
                return predictions;
            }

            // RSI анализ
            const rsiData = calculateRSI(selectedNumber);
            predictions.push({
                title: '📊 НАСКОЛЬКО "РАЗОГРЕТ" НОМЕР',
                description: `Показывает, как часто номер выпадал в последнее время (0-100)`,
                value: rsiData.status,
                color: rsiData.rsi > 70 ? '#ff4444' : rsiData.rsi < 30 ? '#44aa44' : '#ff9800'
            });

            // Скользящие средние
            const maData = calculateMovingAverages(selectedNumber);


            // Индикатор долга
            const debtData = calculateDebtIndicator(selectedNumber);
            predictions.push({
                title: '⏰ КОГДА ПОСЛЕДНИЙ РАЗ ВЫПАДАЛ',
                description: `Не выпадал ${debtData.debt} тиражей подряд`,
                value: debtData.status,
                color: debtData.debt > 15 ? '#44aa44' : debtData.debt > 10 ? '#ff9800' : '#ff4444'
            });

            // Графические паттерны
            const patternData = analyzeChartPatterns(selectedNumber);
            if (patternData.patterns.length > 0) {
                patternData.patterns.forEach(pattern => {
                    predictions.push({
                        title: pattern.name,
                        description: pattern.description,
                        value: pattern.signal,
                        color: pattern.color
                    });
                });
            } else {
                predictions.push({
                    title: '📊 ГРАФИЧЕСКИЕ ПАТТЕРНЫ',
                    description: 'Анализ фигур на графике частоты',
                    value: patternData.summary,
                    color: '#9c27b0'
                });
            }

            // Статистический анализ ожиданий
            const statisticalAnalysis = calculateStatisticalExpectations(selectedNumber);
            predictions.push({
                title: '📈 МАТЕМАТИЧЕСКОЕ ОЖИДАНИЕ',
                description: 'Среднее количество тиражей между выпадениями',
                value: statisticalAnalysis.expectedGap,
                color: '#673ab7'
            });

            predictions.push({
                title: '📊 ДОВЕРИТЕЛЬНЫЕ ИНТЕРВАЛЫ',
                description: 'Статистические диапазоны вероятности выпадения',
                value: statisticalAnalysis.confidenceIntervals,
                color: '#3f51b5'
            });

            predictions.push({
                title: '🎯 СТАТИСТИЧЕСКИЙ РЕЙТИНГ',
                description: 'Позиция номера среди всех 49 номеров',
                value: statisticalAnalysis.ranking,
                color: '#2196f3'
            });

            predictions.push({
                title: '📉 АНАЛИЗ СТАБИЛЬНОСТИ',
                description: 'Насколько предсказуем номер (коэффициент вариации)',
                value: statisticalAnalysis.stability,
                color: '#00bcd4'
            });

            predictions.push({
                title: '📊 КВАНТИЛИ ВЕРОЯТНОСТИ',
                description: '25%, 50%, 75% вероятности выпадения',
                value: statisticalAnalysis.quantiles,
                color: '#ff9800'
            });

            predictions.push({
                title: '🎯 ДОВЕРИТЕЛЬНЫЕ ИНТЕРВАЛЫ',
                description: 'Статистические диапазоны с 95% уверенностью',
                value: statisticalAnalysis.confidence95,
                color: '#e91e63'
            });

            predictions.push({
                title: '📈 СРАВНИТЕЛЬНЫЙ АНАЛИЗ',
                description: 'Позиция среди всех 49 номеров',
                value: statisticalAnalysis.comparative,
                color: '#9c27b0'
            });

            predictions.push({
                title: '📅 АНАЛИЗ СЕЗОННОСТИ',
                description: 'Закономерности по дням недели и месяцам',
                value: statisticalAnalysis.seasonality,
                color: '#795548'
            });

            // Анализ тренда
            const recentAppearances = numberData.slice(-5);
            const trend = analyzeTrend(recentAppearances);
            
            predictions.push({
                title: '📉 ТРЕНД',
                description: 'Анализ последних выпадений',
                value: trend,
                color: trend.includes('Ускоряется') ? '#4caf50' : trend.includes('Замедляется') ? '#f44336' : '#ff9800'
            });

            // Прогноз следующего выпадения
            const nextPrediction = predictNextAppearance(numberData);
            predictions.push({
                title: '🔮 ПРОГНОЗ',
                description: 'Ожидаемый тираж',
                value: nextPrediction,
                color: '#9c27b0'
            });

            // Рекомендация
            const recommendation = getRecommendation(numberData);
            predictions.push({
                title: '🎯 СТАТУС НОМЕРА',
                description: recommendation.description,
                value: recommendation.text,
                color: recommendation.color
            });
            
            predictions.push({
                title: '📈 ВЕРОЯТНОСТЬ ВЫПАДЕНИЯ',
                description: 'Оценка на основе недавней активности',
                value: recommendation.probability,
                color: recommendation.color
            });
            
            predictions.push({
                title: '💡 ЧТО ДЕЛАТЬ',
                description: 'Практические советы',
                value: recommendation.action,
                color: '#9c27b0'
            });

            return predictions;
        }

        // Анализ тренда (понятная логика)
        function analyzeTrend(recentAppearances) {
            if (recentAppearances.length < 3) {
                return 'Недостаточно данных';
            }

            // Анализируем последние 5 выпадений
            const lastFive = recentAppearances.slice(-5);
            if (lastFive.length < 3) {
                return 'Недостаточно данных';
            }

            const gaps = [];
            for (let i = 1; i < lastFive.length; i++) {
                if (lastFive[i].draw_number && lastFive[i-1].draw_number) {
                    const gap = parseInt(lastFive[i].draw_number) - parseInt(lastFive[i-1].draw_number);
                    gaps.push(gap);
                }
            }

            if (gaps.length < 2) {
                return 'Недостаточно данных';
            }

            const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
            const lastGap = gaps[gaps.length - 1];

            // ПОНЯТНАЯ ЛОГИКА:
            // Если последний промежуток меньше среднего = номер выпадает ЧАЩЕ
            // Если последний промежуток больше среднего = номер выпадает РЕЖЕ
            if (lastGap < avgGap * 0.8) {
                return 'Ускоряется (выпадает чаще)';
            } else if (lastGap > avgGap * 1.2) {
                return 'Замедляется (выпадает реже)';
            } else {
                return 'Стабильный';
            }
        }

        // Прогноз следующего выпадения с математической вероятностью
        function predictNextAppearance(numberData) {
            if (numberData.length < 2) {
                return 'Недостаточно данных';
            }

            const gaps = [];
            for (let i = 1; i < numberData.length; i++) {
                if (numberData[i].draw_number && numberData[i-1].draw_number) {
                    const gap = parseInt(numberData[i].draw_number) - parseInt(numberData[i-1].draw_number);
                    gaps.push(gap);
                }
            }

            if (gaps.length === 0) {
                return 'Недостаточно данных';
            }

            const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
            const lastDrawNumber = parseInt(numberData[numberData.length - 1].draw_number);
            const predictedDraw = Math.round(lastDrawNumber + avgGap);
            const range = Math.round(avgGap * 0.3);
            
            // Расчет математической вероятности
            const probability = calculateMathematicalProbability(selectedNumber, predictedDraw, range);
            
            return `Тираж №${predictedDraw} (±${range}) с вероятностью ${probability}%`;
        }

        // Расчет математической вероятности появления номера
        function calculateMathematicalProbability(number, predictedDraw, range) {
            const numberData = lottoData.number_data[number] || [];
            const totalDraws = lottoData.draws.length;
            
            // Базовая вероятность (частота выпадений)
            const baseProbability = (numberData.length / totalDraws) * 100;
            
            // Модификаторы на основе текущего статуса
            let statusModifier = 0;
            const recentDraws = lottoData.draws.slice(0, 20);
            let recentCount = 0;
            recentDraws.forEach(draw => {
                if (draw.numbers.includes(number)) recentCount++;
            });
            const recentFrequency = recentCount / recentDraws.length;
            const expectedFrequency = numberData.length / totalDraws;
            
            // Если номер холодный (выпадает реже обычного)
            if (recentFrequency < expectedFrequency * 0.5) {
                statusModifier = 25; // +25% к вероятности
            }
            // Если номер горячий (выпадает чаще обычного)
            else if (recentFrequency > expectedFrequency * 1.5) {
                statusModifier = -20; // -20% к вероятности
            }
            
            // Модификатор на основе "долга" (сколько тиражей не выпадал)
            const debtData = calculateDebtIndicator(number);
            let debtModifier = 0;
            if (debtData.debt > 20) {
                debtModifier = 30; // +30% если очень давно не выпадал
            } else if (debtData.debt > 15) {
                debtModifier = 20; // +20% если давно не выпадал
            } else if (debtData.debt > 10) {
                debtModifier = 10; // +10% если недавно не выпадал
            } else if (debtData.debt < 3) {
                debtModifier = -15; // -15% если недавно выпадал
            }
            
            // Модификатор на основе тренда (исправленная логика)
            let trendModifier = 0;
            const trend = calculateNumberTrend(number);
            if (trend === 'up') {
                // Если тренд ускоряется И номер холодный - высокая вероятность
                if (recentFrequency < expectedFrequency * 0.7) {
                    trendModifier = 15; // +15%
                } else {
                    trendModifier = -10; // -10% если горячий номер ускоряется
                }
            } else if (trend === 'down') {
                // Если тренд замедляется И номер холодный - ищем критическую точку
                if (recentFrequency < expectedFrequency * 0.5 && debtData.debt > 15) {
                    trendModifier = 20; // +20% - критическая точка разворота
                } else {
                    trendModifier = -5; // -5% в остальных случаях
                }
            }
            
            // Итоговая вероятность
            let finalProbability = baseProbability + statusModifier + debtModifier + trendModifier;
            
            // Ограничиваем вероятность от 5% до 95%
            finalProbability = Math.max(5, Math.min(95, finalProbability));
            
            return Math.round(finalProbability);
        }

        // Статистический анализ ожиданий (честная математика)
        function calculateStatisticalExpectations(number) {
            const numberData = lottoData.number_data[number] || [];
            if (numberData.length < 3) {
                return {
                    expectedGap: 'Недостаточно данных',
                    confidenceIntervals: 'Недостаточно данных',
                    ranking: 'Недостаточно данных',
                    stability: 'Недостаточно данных'
                };
            }

            // 1. Математическое ожидание (средний промежуток)
            const gaps = [];
            for (let i = 1; i < numberData.length; i++) {
                if (numberData[i].draw_number && numberData[i-1].draw_number) {
                    const gap = Math.abs(parseInt(numberData[i].draw_number) - parseInt(numberData[i-1].draw_number));
                    gaps.push(gap);
                }
            }
            
            const expectedGap = gaps.length > 0 ? (gaps.reduce((a, b) => a + b, 0) / gaps.length).toFixed(1) : 0;
            
            // 2. Доверительные интервалы (25%, 50%, 75% квантили)
            const sortedGaps = gaps.sort((a, b) => a - b);
            const q25 = sortedGaps[Math.floor(sortedGaps.length * 0.25)];
            const q50 = sortedGaps[Math.floor(sortedGaps.length * 0.5)];
            const q75 = sortedGaps[Math.floor(sortedGaps.length * 0.75)];
            
            const confidenceIntervals = `25%: ${q25}, 50%: ${q50}, 75%: ${q75} тиражей`;
            
            // 3. Статистический рейтинг среди всех номеров
            const allFrequencies = [];
            for (let i = 1; i <= 49; i++) {
                const numData = lottoData.number_data[i] || [];
                const frequency = numData.length / lottoData.draws.length;
                allFrequencies.push({ number: i, frequency: frequency });
            }
            
            allFrequencies.sort((a, b) => b.frequency - a.frequency);
            const currentFrequency = numberData.length / lottoData.draws.length;
            const rank = allFrequencies.findIndex(item => item.number === number) + 1;
            const percentile = Math.round((1 - (rank - 1) / 49) * 100);
            
            const ranking = `Ранг: ${rank}/49 (${percentile}% лучших)`;
            
            // 4. Анализ стабильности (коэффициент вариации)
            const mean = gaps.reduce((a, b) => a + b, 0) / gaps.length;
            const variance = gaps.reduce((sum, gap) => sum + Math.pow(gap - mean, 2), 0) / gaps.length;
            const stdDev = Math.sqrt(variance);
            const coefficientOfVariation = (stdDev / mean * 100).toFixed(1);
            
            let stabilityLevel;
            if (coefficientOfVariation < 30) stabilityLevel = 'Очень стабильный';
            else if (coefficientOfVariation < 50) stabilityLevel = 'Стабильный';
            else if (coefficientOfVariation < 70) stabilityLevel = 'Умеренно стабильный';
            else stabilityLevel = 'Нестабильный';
            
            const stability = `${stabilityLevel} (CV: ${coefficientOfVariation}%)`;

            // 5. Квантили вероятности (более детальные)
            const q10 = sortedGaps[Math.floor(sortedGaps.length * 0.1)];
            const q90 = sortedGaps[Math.floor(sortedGaps.length * 0.9)];
            const quantiles = `10%: ${q10}, 25%: ${q25}, 50%: ${q50}, 75%: ${q75}, 90%: ${q90} тиражей`;

            // 6. Доверительные интервалы (95% уверенность)
            const z95 = 1.96; // Z-значение для 95% доверительного интервала
            const marginOfError = z95 * (stdDev / Math.sqrt(gaps.length));
            const lowerBound = Math.max(1, Math.round(mean - marginOfError));
            const upperBound = Math.round(mean + marginOfError);
            const confidence95 = `95% уверенность: ${lowerBound}-${upperBound} тиражей`;

            // 7. Сравнительный анализ
            const totalNumbers = 49;
            const betterThan = allFrequencies.filter(item => item.frequency < currentFrequency).length;
            const worseThan = allFrequencies.filter(item => item.frequency > currentFrequency).length;
            const comparative = `Лучше ${betterThan} номеров, хуже ${worseThan} номеров из ${totalNumbers}`;

            // 8. Анализ сезонности (по дням недели и месяцам)
            const seasonality = analyzeSeasonality(number);

            return {
                expectedGap: `${expectedGap} тиражей`,
                confidenceIntervals: confidenceIntervals,
                ranking: ranking,
                stability: stability,
                quantiles: quantiles,
                confidence95: confidence95,
                comparative: comparative,
                seasonality: seasonality
            };
        }

        // Анализ сезонности (закономерности по времени)
        function analyzeSeasonality(number) {
            const numberData = lottoData.number_data[number] || [];
            if (numberData.length < 10) {
                return 'Недостаточно данных для анализа сезонности';
            }

            // Анализ по дням недели
            const dayStats = {};
            const monthStats = {};
            
            numberData.forEach(appearance => {
                if (appearance.date) {
                    const date = new Date(appearance.date);
                    const dayOfWeek = date.getDay(); // 0 = воскресенье, 1 = понедельник, etc.
                    const month = date.getMonth(); // 0 = январь, 1 = февраль, etc.
                    
                    const dayNames = ['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб'];
                    const monthNames = ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 
                                     'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'];
                    
                    const dayName = dayNames[dayOfWeek];
                    const monthName = monthNames[month];
                    
                    dayStats[dayName] = (dayStats[dayName] || 0) + 1;
                    monthStats[monthName] = (monthStats[monthName] || 0) + 1;
                }
            });

            // Находим наиболее активные дни и месяцы
            const bestDay = Object.entries(dayStats).reduce((a, b) => dayStats[a[0]] > dayStats[b[0]] ? a : b);
            const bestMonth = Object.entries(monthStats).reduce((a, b) => monthStats[a[0]] > monthStats[b[0]] ? a : b);
            
            const totalAppearances = numberData.length;
            const dayPercentage = ((bestDay[1] / totalAppearances) * 100).toFixed(1);
            const monthPercentage = ((bestMonth[1] / totalAppearances) * 100).toFixed(1);

            return `Лучший день: ${bestDay[0]} (${dayPercentage}%), лучший месяц: ${bestMonth[0]} (${monthPercentage}%)`;
        }

        // Получение рекомендации (улучшенная логика)
        function getRecommendation(numberData) {
            const appearances = numberData.length;
            const totalDraws = lottoData.draws.length;
            const overallFrequency = appearances / totalDraws;
            const trend = calculateNumberTrend(selectedNumber);

            // Анализируем последние 20 тиражей
            const recentDraws = lottoData.draws.slice(0, 20);
            let recentCount = 0;
            recentDraws.forEach(draw => {
                if (draw.numbers.includes(selectedNumber)) {
                    recentCount++;
                }
            });

            const recentFrequency = recentCount / recentDraws.length;
            const frequencyRatio = recentFrequency / overallFrequency;

            // ЛОГИЧНАЯ СИСТЕМА РЕКОМЕНДАЦИЙ:
            // Основана на сравнении недавней активности с общей статистикой
            
            if (trend === 'very-hot') {
                return {
                    text: '🔥 ОЧЕНЬ ГОРЯЧИЙ!',
                    description: `Выпадает в ${frequencyRatio.toFixed(1)} раза чаще обычного. Последние 20 тиражей: ${recentCount} раз.`,
                    action: '⚠️ ВНИМАНИЕ: Номер "перегрет"! Высокий риск паузы. Лучше подождать.',
                    color: '#ff4444',
                    probability: 'НИЗКАЯ вероятность в ближайших тиражах'
                };
            } else if (trend === 'hot') {
                return {
                    text: '🟠 ГОРЯЧИЙ',
                    description: `Выпадает в ${frequencyRatio.toFixed(1)} раза чаще обычного. Последние 20 тиражей: ${recentCount} раз.`,
                    action: '⚡ ОСТОРОЖНО: Может продолжить активность, но риск остывания растет.',
                    color: '#ff8800',
                    probability: 'СРЕДНЯЯ вероятность в ближайших тиражах'
                };
            } else if (trend === 'cold') {
                return {
                    text: '🟢 ХОЛОДНЫЙ',
                    description: `Выпадает в ${frequencyRatio.toFixed(1)} раза реже обычного. Последние 20 тиражей: ${recentCount} раз.`,
                    action: '✅ ХОРОШО: Номер "должен" выпасть по теории вероятностей.',
                    color: '#44aa44',
                    probability: 'ВЫСОКАЯ вероятность в ближайших тиражах'
                };
            } else if (trend === 'very-cold') {
                return {
                    text: '🔵 ОЧЕНЬ ХОЛОДНЫЙ!',
                    description: `Выпадает в ${frequencyRatio.toFixed(1)} раза реже обычного. Последние 20 тиражей: ${recentCount} раз.`,
                    action: '🎯 ОТЛИЧНО: Номер "переохлажден"! Очень высокая вероятность скорого появления.',
                    color: '#0066cc',
                    probability: 'ОЧЕНЬ ВЫСОКАЯ вероятность в ближайших тиражах'
                };
            } else {
                return {
                    text: '⚪ СТАБИЛЬНЫЙ',
                    description: `Выпадает с обычной частотой. Последние 20 тиражей: ${recentCount} раз.`,
                    action: '📊 НЕЙТРАЛЬНО: Стабильный выбор для долгосрочной игры.',
                    color: '#888888',
                    probability: 'СРЕДНЯЯ вероятность в ближайших тиражах'
                };
            }
        }

        // Добавление нового тиража
        function addNewDraw() {
            const date = document.getElementById('newDate').value;
            const drawNumber = document.getElementById('newDrawNumber').value;
            const numbersStr = document.getElementById('newNumbers').value;

            if (!date || !drawNumber || !numbersStr) {
                showError('Заполните все поля');
                return;
            }

            try {
                // Поддержка ввода через запятую или пробел
            const numbers = numbersStr.split(/[,\s]+/).map(n => parseInt(n.trim())).filter(n => !isNaN(n));
                
                if (numbers.length !== 6 || numbers.some(n => isNaN(n) || n < 1 || n > 49)) {
                    showError('Введите 6 чисел от 1 до 49 через запятую');
                    return;
                }

                // Добавляем новый тираж
                const newDraw = {
                    date: date.split('-').reverse().join('.'),
                    draw_number: drawNumber,
                    numbers: numbers
                };

                lottoData.draws.unshift(newDraw);

                // Обновляем данные по номерам
                numbers.forEach(number => {
                    if (!lottoData.number_data[number]) {
                        lottoData.number_data[number] = [];
                    }
                    lottoData.number_data[number].unshift({
                        date: newDraw.date,
                        draw_number: drawNumber
                    });
                });

                // Очищаем форму
                document.getElementById('newDate').value = '';
                document.getElementById('newDrawNumber').value = '';
                document.getElementById('newNumbers').value = '';

                // Сохраняем данные в localStorage
                saveData();

                // Обновляем цветовую индикацию
                updateNumberTrends();

                // Обновляем график если выбран номер
                if (selectedNumber) {
                    updateChart();
                }

                showSuccess('Тираж добавлен успешно!');

            } catch (error) {
                showError('Ошибка при добавлении тиража: ' + error.message);
            }
        }

        // Показ ошибки
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.controls').appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }

        // Показ успеха
        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.style.cssText = `
                background: #e8f5e8;
                color: #2e7d32;
                padding: var(--space-md);
                border-radius: var(--radius-md);
                margin: var(--space-sm) 0;
                border-left: 4px solid #2e7d32;
            `;
            successDiv.textContent = message;
            document.querySelector('.controls').appendChild(successDiv);
            setTimeout(() => successDiv.remove(), 3000);
        }

        // Переключение режима редактирования тиражей
        function toggleEditDraws() {
            const editSection = document.getElementById('editDrawsSection');
            if (editSection.style.display === 'none') {
                editSection.style.display = 'block';
                loadDrawsList();
            } else {
                editSection.style.display = 'none';
            }
        }

        // Переменные для пагинации тиражей
        let currentDrawsPage = 0;
        let drawsPerPage = 100;
        let showingAllDraws = false;

        // Загрузка списка тиражей для редактирования с пагинацией
        function loadDrawsList() {
            const drawsList = document.getElementById('drawsList');
            if (!lottoData || !lottoData.draws) {
                drawsList.innerHTML = '<p>Нет данных о тиражах</p>';
                return;
            }

            const totalDraws = lottoData.draws.length;
            const startIndex = showingAllDraws ? 0 : currentDrawsPage * drawsPerPage;
            const endIndex = showingAllDraws ? totalDraws : Math.min(startIndex + drawsPerPage, totalDraws);
            const drawsToShow = lottoData.draws.slice(startIndex, endIndex);

            let html = '<div style="max-height: 400px; overflow-y: auto;">';
            html += '<table style="width: 100%; border-collapse: collapse; margin-bottom: var(--space-lg);">';
            html += '<thead><tr style="background: var(--bg-light);">';
            html += `<th style="padding: var(--space-sm); border: 1px solid var(--bg-lighter);">Дата</th>`;
            html += `<th style="padding: var(--space-sm); border: 1px solid var(--bg-lighter);">Номер</th>`;
            html += `<th style="padding: var(--space-sm); border: 1px solid var(--bg-lighter);">Выигрышные номера</th>`;
            html += `<th style="padding: var(--space-sm); border: 1px solid var(--bg-lighter);">Действия</th>`;
            html += '</tr></thead><tbody>';

            drawsToShow.forEach((draw, index) => {
                const actualIndex = startIndex + index;
                html += '<tr>';
                html += `<td style="padding: var(--space-xs); border: 1px solid var(--bg-lighter);">${draw.date}</td>`;
                html += `<td style="padding: var(--space-xs); border: 1px solid var(--bg-lighter);">${draw.draw_number}</td>`;
                html += `<td style="padding: var(--space-xs); border: 1px solid var(--bg-lighter);">${draw.numbers.join(', ')}</td>`;
                html += `<td style="padding: var(--space-xs); border: 1px solid var(--bg-lighter);">`;
                html += `<button onclick="editDraw(${actualIndex})" style="margin-right: var(--space-xs); padding: var(--space-xs) var(--space-sm); background: var(--primary-color); color: var(--text-light); border: none; border-radius: var(--radius-sm); cursor: pointer;">Изменить</button>`;
                html += `<button onclick="deleteDraw(${actualIndex})" style="padding: var(--space-xs) var(--space-sm); background: var(--danger); color: var(--text-light); border: none; border-radius: var(--radius-sm); cursor: pointer;">Удалить</button>`;
                html += '</td>';
                html += '</tr>';
            });

            html += '</tbody></table>';
            
            // Информация о пагинации
            if (showingAllDraws) {
                html += `<p style="color: var(--text-muted); font-size: 0.9em;">Показаны все ${totalDraws} тиражей</p>`;
            } else {
                html += `<p style="color: var(--text-muted); font-size: 0.9em;">Показаны тиражи ${startIndex + 1}-${endIndex} из ${totalDraws}</p>`;
            }
            
            // Кнопки навигации
            html += `<div style="margin-top: var(--space-md); text-align: center; padding: var(--space-sm); background: var(--bg-light); border-radius: var(--radius-md);">`;
            
            if (!showingAllDraws && endIndex < totalDraws) {
                html += `<button onclick="loadMoreDraws()" style="margin: 0 var(--space-xs); padding: var(--space-xs) var(--space-lg); background: var(--success); color: var(--text-light); border: none; border-radius: var(--radius-sm); cursor: pointer;">Загрузить еще ${drawsPerPage}</button>`;
            }
            
            if (!showingAllDraws && totalDraws > drawsPerPage) {
                html += `<button onclick="showAllDraws()" style="margin: 0 var(--space-xs); padding: var(--space-xs) var(--space-lg); background: var(--info); color: var(--text-light); border: none; border-radius: var(--radius-sm); cursor: pointer;">Показать все</button>`;
            }
            
            if (showingAllDraws || currentDrawsPage > 0) {
                html += `<button onclick="resetDrawsView()" style="margin: 0 var(--space-xs); padding: var(--space-xs) var(--space-lg); background: var(--secondary); color: var(--text-light); border: none; border-radius: var(--radius-sm); cursor: pointer;">Сбросить</button>`;
            }
            
            html += '</div>';
            html += '</div>';

            drawsList.innerHTML = html;
        }

        // Функции для управления пагинацией тиражей
        function loadMoreDraws() {
            currentDrawsPage++;
            loadDrawsList();
        }

        function showAllDraws() {
            showingAllDraws = true;
            loadDrawsList();
        }

        function resetDrawsView() {
            currentDrawsPage = 0;
            showingAllDraws = false;
            loadDrawsList();
        }

        // Редактирование тиража
        function editDraw(index) {
            const draw = lottoData.draws[index];
            
            // Создаем модальное окно для редактирования
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;

            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 10px; width: 500px; max-width: 90vw;">
                    <h3>Редактирование тиража №${draw.draw_number}</h3>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">Дата:</label>
                        <input type="date" id="editDate" value="${draw.date.split('.').reverse().join('-')}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">Номер тиража:</label>
                        <input type="number" id="editDrawNumber" value="${draw.draw_number}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px;">Выигрышные номера (через запятую или пробел):</label>
                        <input type="text" id="editNumbers" value="${draw.numbers.join(', ')}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    </div>
                    
                    <div style="text-align: right;">
                        <button onclick="saveDrawEdit(${index})" style="margin-right: 10px; padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Сохранить</button>
                        <button onclick="closeEditModal()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Отмена</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // Сохранение изменений тиража
        function saveDrawEdit(index) {
            const date = document.getElementById('editDate').value;
            const drawNumber = document.getElementById('editDrawNumber').value;
            const numbersStr = document.getElementById('editNumbers').value;

            if (!date || !drawNumber || !numbersStr) {
                alert('Заполните все поля');
                return;
            }

            try {
                // Поддержка ввода через запятую или пробел
            const numbers = numbersStr.split(/[,\s]+/).map(n => parseInt(n.trim())).filter(n => !isNaN(n));
                
                if (numbers.length !== 6 || numbers.some(n => isNaN(n) || n < 1 || n > 49)) {
                    alert('Введите 6 чисел от 1 до 49 через запятую');
                    return;
                }

                // Обновляем тираж
                const oldDraw = lottoData.draws[index];
                lottoData.draws[index] = {
                    date: date.split('-').reverse().join('.'),
                    draw_number: drawNumber,
                    numbers: numbers
                };

                // Обновляем данные по номерам
                // Удаляем старые записи
                oldDraw.numbers.forEach(number => {
                    if (lottoData.number_data[number]) {
                        lottoData.number_data[number] = lottoData.number_data[number].filter(item => item.draw_number !== oldDraw.draw_number);
                    }
                });

                // Добавляем новые записи
                numbers.forEach(number => {
                    if (!lottoData.number_data[number]) {
                        lottoData.number_data[number] = [];
                    }
                    lottoData.number_data[number].push({
                        date: lottoData.draws[index].date,
                        draw_number: drawNumber
                    });
                });

                // Сортируем данные по номерам тиражей
                for (let i = 1; i <= 49; i++) {
                    if (lottoData.number_data[i]) {
                        lottoData.number_data[i].sort((a, b) => parseInt(b.draw_number) - parseInt(a.draw_number));
                    }
                }

                // Сохраняем данные в localStorage
                saveData();

                closeEditModal();
                loadDrawsList();
                updateNumberTrends();
                
                if (selectedNumber) {
                    updateChart();
                }

                showSuccess('Тираж обновлен успешно!');

            } catch (error) {
                alert('Ошибка при сохранении: ' + error.message);
            }
        }

        // Удаление тиража
        function deleteDraw(index) {
            if (!confirm('Вы уверены, что хотите удалить этот тираж?')) {
                return;
            }

            const draw = lottoData.draws[index];
            
            // Удаляем записи из данных по номерам
            draw.numbers.forEach(number => {
                if (lottoData.number_data[number]) {
                    lottoData.number_data[number] = lottoData.number_data[number].filter(item => item.draw_number !== draw.draw_number);
                }
            });

            // Удаляем тираж
            lottoData.draws.splice(index, 1);

            // Сохраняем данные в localStorage
            saveData();

            loadDrawsList();
            updateNumberTrends();
            
            if (selectedNumber) {
                updateChart();
            }

            showSuccess('Тираж удален успешно!');
        }

        // Закрытие модального окна
        function closeEditModal() {
            const modal = document.querySelector('div[style*="position: fixed"]');
            if (modal) {
                modal.remove();
            }
        }

        // Выбор стратегии
        function selectStrategy(strategyType) {
            selectedStrategy = strategyType;

            // Очищаем сгенерированные комбинации, если выбрана другая стратегия
            if (window.lastGeneratedStrategy !== null &&
                window.lastGeneratedStrategy !== undefined &&
                window.lastGeneratedStrategy !== strategyType) {
                console.log(`Очищаем комбинации предыдущей стратегии: ${window.lastGeneratedStrategy}`);
                window.lastGeneratedCombinations = null;
                window.lastGeneratedStrategy = null;
            }

            // Обновляем визуал выбранной стратегии
            document.querySelectorAll('.strategy-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelector(`[data-strategy="${strategyType}"]`).classList.add('selected');

            // Показываем новый блок управления (кнопка + селектор)
            document.getElementById('generation-controls').style.display = 'flex';
        }


        // Обновление процентов эффективности в карточках стратегий
        function updateStrategyCardsEfficiency() {
            const strategies = ['conservative', 'balanced', 'aggressive'];
            const testCount = parseInt(document.getElementById('testTirageCount').value, 10) || 20;

            strategies.forEach(strategy => {
                let efficiency = 0;
                let isCombinationEfficiency = false;

                // В карточках стратегий показываем эффективность сгенерированных комбинаций только для той стратегии, для которой они были сгенерированы
                if (window.lastGeneratedCombinations &&
                    window.lastGeneratedCombinations.length > 0 &&
                    window.lastGeneratedStrategy !== null &&
                    window.lastGeneratedStrategy !== undefined &&
                    window.lastGeneratedStrategy === strategy) {
                    // Есть сгенерированные комбинации именно для этой стратегии - тестируем их эффективность
                    console.log(`Тестирование комбинаций для стратегии ${strategy} на ${testCount} тиражах...`);
                    const newEfficiency = testGeneratedCombinationEfficiency(window.lastGeneratedCombinations, testCount);
                    efficiency = newEfficiency;
                    isCombinationEfficiency = true;
                    console.log(`Результат тестирования для ${strategy}: ${efficiency}%`);

                    // Сохраняем текущую эффективность для синхронизации с дашбордом
                    window.currentCombinationEfficiency = {
                        strategy: strategy,
                        efficiency: efficiency,
                        testCount: testCount
                    };
                } else {
                    // Для других стратегий используем ранее закэшированные значения
                    // НЕ пересчитываем их при изменении количества тиражей
                    efficiency = strategyEfficiencyCache[strategy] || 0;
                    console.log(`Кэшированная эффективность стратегии ${strategy}: ${efficiency}%`);
                }

                // Обновляем процент в карточке
                const strategyCard = document.querySelector(`[data-strategy="${strategy}"]`);
                if (strategyCard) {
                    const testElements = strategyCard.querySelectorAll('.stat-label');
                    testElements.forEach((label, index) => {
                        if (label.textContent.includes('ТЕСТ:')) {
                            const valueElement = label.parentElement.querySelector('.stat-value');
                            if (valueElement) {
                                valueElement.textContent = `${efficiency}%`;
                                // Меняем цвет и стиль для эффективности комбинации
                                if (isCombinationEfficiency) {
                                    valueElement.style.color = efficiency > 15 ? '#4caf50' : efficiency > 8 ? '#ff9800' : '#f44336';
                                    valueElement.style.fontWeight = 'bold';
                                    valueElement.style.textShadow = '0 0 3px rgba(0,0,0,0.3)';
                                } else {
                                    valueElement.style.color = '';
                                    valueElement.style.fontWeight = '';
                                    valueElement.style.textShadow = '';
                                }
                            }
                        }
                    });
                }
            });
        }

        // Тестирование эффективности конкретной сгенерированной комбинации
        function testGeneratedCombinationEfficiency(generatedCombinations, numTests = 20) {
            if (!generatedCombinations || generatedCombinations.length === 0) {
                console.log('Нет сгенерированных комбинаций для тестирования');
                return 0;
            }

            // Используем то же количество тиражей, что и в displayStrategyResults
            const userTestCount = parseInt(document.getElementById('testTirageCount').value, 10) || 20;
            const actualTestCount = Math.min(userTestCount, lottoData.draws.length);

            // Убираем требование +10 тиражей, оставляем только базовую проверку
            if (lottoData.draws.length < actualTestCount) {
                console.log(`Недостаточно данных для тестирования на ${actualTestCount} тиражах`);
                return 0;
            }

            // ИСПОЛЬЗУЕМ ТЕ ЖЕ КОМБИНАЦИИ, КОТОРЫЕ ПОКАЗАНЫ ПОЛЬЗОВАТЕЛЮ!
            // Берем самые свежие actualTestCount тиражей для тестирования (как в displayStrategyResults)
            const testDraws = lottoData.draws.slice(0, actualTestCount);

            console.log(`🎯 ТЕСТИРОВАНИЕ ПОКАЗАННЫХ КОМБИНАЦИЙ:`);
            console.log(`   Комбинации для тестирования: ${generatedCombinations.length} шт.`);
            console.log(`   Тестовая выборка: ${testDraws.length} последних тиражей`);
            console.log(`   Комбинации:`, generatedCombinations);

            let totalSuccessfulGames = 0;

            // Тестируем каждую комбинацию отдельно и суммируем успехи
            generatedCombinations.forEach((combo, comboIndex) => {
                let comboWins = 0;

                for (let i = 0; i < testDraws.length; i++) {
                    const actualNumbers = new Set(testDraws[i].numbers);
                    const matches = combo.filter(num => actualNumbers.has(num)).length;

                    if (matches >= 3) { // Минимум 3 совпадения = выигрыш
                        comboWins++;
                        console.log(`✅ Игра ${comboIndex + 1}, Тираж ${testDraws[i].draw_number}: ${matches} совпадений!`);
                    }
                }

                console.log(`   Игра ${comboIndex + 1}: ${comboWins}/${testDraws.length} успехов`);
                totalSuccessfulGames += comboWins;
            });

            // ЭФФЕКТИВНОСТЬ = ОБЩЕЕ КОЛИЧЕСТВО ВЫИГРЫШНЫХ ИГР / ОБЩЕЕ КОЛИЧЕСТВО ИГР
            const totalGames = generatedCombinations.length * actualTestCount;
            const efficiency = totalGames > 0 ? Math.round((totalSuccessfulGames / totalGames) * 100) : 0;

            console.log(`🎯 ОБЩАЯ ЭФФЕКТИВНОСТЬ: ${totalSuccessfulGames}/${totalGames} = ${efficiency}%`);
            console.log(`   - ${totalSuccessfulGames} успешных тестов из ${totalGames} (8 комбинаций × ${actualTestCount} тиражей)`);

            return efficiency;
        }

        // Тестирование эффективности стратегии на исторических данных (для карточек)
        function testStrategyEfficiency(strategyType, numTests = 30) {
            // Используем то же количество тиражей, что и в других функциях
            const userTestCount = parseInt(document.getElementById('testTirageCount').value, 10) || 20;
            const actualTestCount = Math.min(userTestCount, lottoData.draws.length);

            // Убираем требование +10 тиражей, оставляем только базовую проверку
            if (lottoData.draws.length < actualTestCount) {
                console.log(`Недостаточно данных для тестирования на ${actualTestCount} тиражах`);
                return 0;
            }

            let successfulPredictions = 0;
            const totalTests = actualTestCount;

            // Берем самые свежие тиражы для тестирования
            const testDraws = lottoData.draws.slice(0, totalTests);

            for (let i = 0; i < totalTests; i++) {
                // Для теста i используем исторические данные до i-го тиража
                const historicalDraws = lottoData.draws.slice(i + 1, lottoData.draws.length);

                // Создаем временную копию данных только до текущего тиража
                const tempLottoData = {
                    draws: historicalDraws,
                    number_data: createNumberDataFromDraws(historicalDraws)
                };

                // Сохраняем оригинальные данные
                const originalLottoData = lottoData;
                lottoData = tempLottoData;

                try {
                    // Генерируем комбинации стратегией
                    let testCombinations = [];
                    switch (strategyType) {
                        case 'conservative':
                            testCombinations = generateConservativeStrategy(8);
                            break;
                        case 'balanced':
                            testCombinations = generateBalancedStrategy(8);
                            break;
                        case 'aggressive':
                            testCombinations = generateAggressiveStrategy(8);
                            break;
                    }

                    // Проверяем, совпала ли хоть одна комбинация с реальным результатом
                    // Считаем успешным, если совпало минимум 3 номера (уже выигрыш!)
                    const actualNumbers = new Set(testDraws[i].numbers);
                    const hasMatch = testCombinations.some(combo => {
                        const matches = combo.filter(num => actualNumbers.has(num)).length;
                        return matches >= 3; // Минимум 3 совпадения = выигрыш
                    });

                    if (hasMatch) {
                        successfulPredictions++;
                    }

                } catch (error) {
                    console.log(`Ошибка при тестировании тиража ${i}:`, error.message);
                }

                // Восстанавливаем оригинальные данные
                lottoData = originalLottoData;
            }

            const efficiency = totalTests > 0 ? Math.round((successfulPredictions / totalTests) * 100) : 0;
            console.log(`Стратегия ${strategyType}: ${successfulPredictions}/${totalTests} успешных предсказаний = ${efficiency}%`);

            return efficiency;
        }

        // Кэш результатов тестирования
        let strategyEfficiencyCache = {};

        // Обновление дашборда стратегии с реальным тестированием
        function updateStrategyDashboard() {
            const titleElement = document.getElementById('selected-strategy-title');
            const efficiencyBar = document.getElementById('efficiency-bar');
            const efficiencyLabel = document.getElementById('efficiency-label');

            // Проверяем, существуют ли элементы (блок strategy-dashboard может быть скрыт)
            if (!titleElement || !efficiencyBar || !efficiencyLabel) {
                console.log('Элементы strategy-dashboard не найдены или скрыты, пропускаем обновление');
                return;
            }

            const strategyNames = {
                conservative: '🛡️ КОНСЕРВАТИВНАЯ СТРАТЕГИЯ',
                balanced: '⚖️ СБАЛАНСИРОВАННАЯ СТРАТЕГИЯ',
                aggressive: '🎯 АГРЕССИВНАЯ СТРАТЕГИЯ'
            };

            const strategyDescriptions = {
                conservative: 'Стабильные номера с низкой волатильностью. Реже дают джекпот, но чаще угадывают номера',
                balanced: 'Оптимальный баланс риска и шанса. Лучший выбор для регулярной игры',
                aggressive: 'Максимальный риск для максимального выигрыша. Редко, но точно!'
            };

            // Проверяем, есть ли уже сгенерированная комбинация для тестирования
            const resultsContainer = document.getElementById('generator-results-container');
            const hasGeneratedCombination = resultsContainer && resultsContainer.innerHTML.trim() !== '';

            let efficiency = 0;
            let testCount = parseInt(document.getElementById('testTirageCount').value, 10) || 20;
            let efficiencyType = 'стратегии';

            if (hasGeneratedCombination && window.currentCombinationEfficiency) {
                // Если есть сгенерированная комбинация, используем её сохраненную эффективность
                efficiency = window.currentCombinationEfficiency.efficiency;
                    efficiencyType = 'вашей комбинации';
            } else {
                // Если нет сгенерированной комбинации, показываем общую эффективность стратегии
                if (!strategyEfficiencyCache[selectedStrategy] || strategyEfficiencyCache[selectedStrategy + '_count'] !== testCount) {
                    console.log(`Тестируем общую эффективность стратегии ${selectedStrategy} на ${testCount} тиражах...`);
                    strategyEfficiencyCache[selectedStrategy] = testStrategyEfficiency(selectedStrategy, testCount);
                    strategyEfficiencyCache[selectedStrategy + '_count'] = testCount;
                }
                efficiency = strategyEfficiencyCache[selectedStrategy] || 0;
            }

            // Если есть сгенерированные комбинации именно для выбранной стратегии, пересчитываем их эффективность
            if (hasGeneratedCombination &&
                window.lastGeneratedCombinations &&
                window.lastGeneratedStrategy !== null &&
                window.lastGeneratedStrategy !== undefined &&
                window.lastGeneratedStrategy === selectedStrategy) {
                console.log(`Пересчет эффективности комбинаций для стратегии ${selectedStrategy} на ${testCount} тиражах...`);
                const combinations = window.lastGeneratedCombinations;
                const realEfficiency = testGeneratedCombinationEfficiency(combinations, testCount);
                efficiency = realEfficiency;
                efficiencyType = 'вашей комбинации';
                console.log(`Эффективность комбинаций: ${efficiency}%`);

                // Обновляем currentCombinationEfficiency для синхронизации
                window.currentCombinationEfficiency = {
                    strategy: selectedStrategy,
                    efficiency: realEfficiency,
                    testCount: testCount
                };
            }

            const efficiencyColor = efficiency > 15 ? '#4caf50' : efficiency > 8 ? '#ff9800' : '#f44336';
            const efficiencyStatus = efficiency > 15 ? 'Отличная' : efficiency > 8 ? 'Хорошая' : 'Низкая';

            titleElement.innerHTML = `
                ${strategyNames[selectedStrategy] || 'Стратегия не выбрана'}
                <div style="font-size: 0.8em; color: #666; margin-top: 5px; font-weight: normal;">
                    ${strategyDescriptions[selectedStrategy] || ''}
                </div>
                ${hasGeneratedCombination ? `
                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px; border-left: 3px solid ${efficiencyColor};">
                    <div style="font-size: 0.9em; color: ${efficiencyColor}; font-weight: bold;">
                        🎯 Ваша комбинация: ${efficiencyStatus} (${efficiency}%)
                    </div>
                    <div style="font-size: 0.7em; color: #ccc; margin-top: 2px;">
                        Протестировано на ${testCount} прошлых тиражах
                    </div>
                </div>
                ` : ''}
            `;

            efficiencyBar.style.width = `${efficiency}%`;

            efficiencyLabel.textContent = `Эффективность ${efficiencyType}: ${efficiency}% (на основе ${testCount} тиражей)`;
        }

        // Генерация выбранной стратегии
        function generateSelectedStrategy() {
            if (!selectedStrategy) {
                showError('Выберите стратегию');
                    return;
                }

            if (!lottoData) {
                showError('Данные еще не загружены');
                return;
            }

            const numCombinations = parseInt(document.getElementById('numCombinations').value, 10);
            if (isNaN(numCombinations) || numCombinations < 1) {
                showError('Введите корректное количество комбинаций');
                    return;
                }

            // Генерируем комбинации в зависимости от выбранной стратегии
                    let combinations = [];
                    let title = '';

            try {
                switch (selectedStrategy) {
                    case 'conservative':
                        title = '🛡️ Консервативная Стратегия';
                        combinations = generateConservativeStrategy(numCombinations);
                        break;
                    case 'balanced':
                        title = '⚖️ Сбалансированная Стратегия';
                        combinations = generateBalancedStrategy(numCombinations);
                        break;

                    case 'ai':
                        title = '🤖 ИИ-ПРЕДСКАЗАНИЕ';
                        combinations = generateAIStrategy(numCombinations);
                        break;
                }

                // Сохраняем сгенерированную комбинацию для тестирования
                window.lastGeneratedCombinations = combinations;
                window.lastGeneratedStrategy = selectedStrategy;
                console.log(`Сохранены комбинации для стратегии: ${selectedStrategy}, количество: ${combinations.length}`);

                // Тестируем эффективность именно ЭТОЙ сгенерированной комбинации
                const testCount = parseInt(document.getElementById('testTirageCount').value, 10) || 20;
                const realEfficiency = testGeneratedCombinationEfficiency(combinations, testCount);

                // Сохраняем эффективность этой конкретной комбинации
                window.currentCombinationEfficiency = {
                    strategy: selectedStrategy,
                    efficiency: realEfficiency,
                    testCount: testCount
                };

                // Сохраняем комбинации для повторного использования
                window.lastGeneratedCombinations = combinations;

                displayStrategyResults(combinations, title, realEfficiency, testCount);

                // Обновляем карточки стратегий после генерации комбинации
                updateStrategyCardsEfficiency();

                // Обновляем дашборд стратегии с новой эффективностью комбинации
                updateStrategyDashboard();
            } catch (error) {
                console.error('Ошибка генерации:', error);
                showError('Ошибка при генерации комбинаций');
            }
        }


        /**
         * Анализ кластерного поведения номеров - определяет номера, которые часто выпадали вместе.
         */
        function analyzeClusterBehavior(dataToUse) {
            const clusterBonuses = {};
            const recentDraws = dataToUse.draws.slice(0, 50); // Последние 50 тиражей
            const numberCooccurrence = {};

            // Инициализируем матрицу со-встречаемости
            for (let i = 1; i <= 49; i++) {
                numberCooccurrence[i] = {};
                for (let j = 1; j <= 49; j++) {
                    numberCooccurrence[i][j] = 0;
                }
            }

            // Подсчитываем со-встречаемость
            recentDraws.forEach(draw => {
                const numbers = draw.numbers;
                for (let i = 0; i < numbers.length; i++) {
                    for (let j = i + 1; j < numbers.length; j++) {
                        numberCooccurrence[numbers[i]][numbers[j]]++;
                        numberCooccurrence[numbers[j]][numbers[i]]++;
                    }
                }
            });

            // Находим номера, которые часто встречаются вместе
            for (let i = 1; i <= 49; i++) {
                let totalCooccurrence = 0;
                let cooccurrenceCount = 0;

                for (let j = 1; j <= 49; j++) {
                    if (i !== j && numberCooccurrence[i][j] > 0) {
                        totalCooccurrence += numberCooccurrence[i][j];
                        cooccurrenceCount++;
                    }
                }

                if (cooccurrenceCount > 0) {
                    const avgCooccurrence = totalCooccurrence / cooccurrenceCount;
                    // Даем бонус номерам, которые часто встречаются с другими
                    if (avgCooccurrence > 2) { // Встречались вместе более 2 раз
                        clusterBonuses[i] = Math.min(2.0, avgCooccurrence * 0.3);
                    }
                }
            }

            return clusterBonuses;
        }

        /**
         * Анализ кластерного поведения номеров - определяет номера, которые часто выпадали вместе.
         */
        function analyzeClusterBehavior(dataToUse) {
            const clusterBonuses = {};
            const recentDraws = dataToUse.draws.slice(0, 50); // Последние 50 тиражей
            const numberCooccurrence = {};

            // Инициализируем матрицу со-встречаемости
            for (let i = 1; i <= 49; i++) {
                numberCooccurrence[i] = {};
                for (let j = 1; j <= 49; j++) {
                    numberCooccurrence[i][j] = 0;
                }
            }

            // Подсчитываем со-встречаемость
            recentDraws.forEach(draw => {
                const numbers = draw.numbers;
                for (let i = 0; i < numbers.length; i++) {
                    for (let j = i + 1; j < numbers.length; j++) {
                        numberCooccurrence[numbers[i]][numbers[j]]++;
                        numberCooccurrence[numbers[j]][numbers[i]]++;
                    }
                }
            });

            // Находим номера, которые часто встречаются вместе
            for (let i = 1; i <= 49; i++) {
                let totalCooccurrence = 0;
                let cooccurrenceCount = 0;

                for (let j = 1; j <= 49; j++) {
                    if (i !== j && numberCooccurrence[i][j] > 0) {
                        totalCooccurrence += numberCooccurrence[i][j];
                        cooccurrenceCount++;
                    }
                }

                if (cooccurrenceCount > 0) {
                    const avgCooccurrence = totalCooccurrence / cooccurrenceCount;
                    // Даем бонус номерам, которые часто встречаются с другими
                    if (avgCooccurrence > 2) { // Встречались вместе более 2 раз
                        clusterBonuses[i] = Math.min(2.0, avgCooccurrence * 0.3);
                    }
                }
            }

            return clusterBonuses;
        }

        // ===============================================================================================
        // ТЕСТОВЫЕ ФУНКЦИИ
        // ===============================================================================================

        // Тестовая функция для проверки analyzeClusterBehavior
        window.testClusterBehavior = function() {
            console.log('Тестирование analyzeClusterBehavior...');
            const clusterBonuses = analyzeClusterBehavior(lottoData);
            console.log('Результат:', Object.keys(clusterBonuses).length, 'номеров с бонусами');
            return clusterBonuses;
        };

        // Тестовая функция для проверки getSmartTargetNumbers
        window.testSmartTargets = function() {
            console.log('Тестирование getSmartTargetNumbers...');
            const targets = getSmartTargetNumbers(15, lottoData);
            console.log('Топ-10 целей:', targets.slice(0, 10));
            return targets;
        };

        // ===============================================================================================
        // ФИНАЛЬНАЯ ГИБРИДНАЯ СТРАТЕГИЯ (v2.2 - Smart Target AI)
        // ===============================================================================================

        /**
         * "Псевдо-нейронный" алгоритм для определения 6 самых "влиятельных" номеров.
         * @param {number} historySize - Количество последних тиражей для анализа.
         * @param {object} dataToUse - Данные для анализа.
         * @returns {Array<number>} - Массив из 6 целевых номеров.
         */
        function getSmartTargetNumbers(historySize, dataToUse) {
            if (!dataToUse.draws || dataToUse.draws.length < historySize) {
                // Если данных мало, возвращаем номера из последнего тиража или пустой массив
                console.log(`⚠️ Недостаточно данных для смарт-анализа, используется последний тираж.`);
                return (dataToUse.draws && dataToUse.draws.length > 0) ? [...dataToUse.draws[0].numbers] : [];
            }

            const recentDraws = dataToUse.draws.slice(0, historySize);
            const numberScores = {};

            for (let i = 1; i <= 49; i++) {
                numberScores[i] = { score: 0, number: i };
            }

            // Анализируем последние тиражи
            recentDraws.forEach((draw, index) => {
                // Вес от 1.0 (самый новый) до ~0.0 (самый старый в выборке)
                const recencyWeight = (historySize - index) / historySize;

                draw.numbers.forEach(num => {
                    // 1. Бонус за частоту и свежесть
                    numberScores[num].score += 1 * recencyWeight;
                });
            });

            // 2. Дополнительный бонус за "горячесть" и стабильность на основе общего тренда
            for (let i = 1; i <= 49; i++) {
                const trend = calculateNumberTrend(i); // Используем существующую функцию
                const numberData = dataToUse.number_data[i] || [];
                const { debt } = calculateDebtIndicator(i);
                const { avgGap, cv } = calculateGapStats(numberData);

                if (trend.status === 'very-hot') {
                    numberScores[i].score += 2.0; // Увеличен бонус за очень горячую фазу
                } else if (trend.status === 'hot') {
                    numberScores[i].score += 1.0; // Увеличен бонус за горячую фазу
                }

                // Максимально усиленные бонусы за короткие паузы и стабильность
                if (avgGap > 0) {
                    const debtRatio = debt / avgGap;
                    if (debtRatio < 0.6 && cv < 0.9) { // Расширенные критерии
                        numberScores[i].score += 3.0; // Максимальный бонус
                    } else if (debtRatio < 0.8 && cv < 1.1) { // Еще более широкие критерии
                        numberScores[i].score += 2.5; // Большой бонус
                    } else if (debtRatio < 1.0 && cv < 1.0) { // Широкие критерии
                        numberScores[i].score += 1.8; // Хороший бонус
                    } else if (debtRatio < 1.2) { // Просто короткая пауза
                        numberScores[i].score += 1.2; // Бонус за свежесть
                    } else if (cv < 0.8) { // Просто хорошая стабильность
                        numberScores[i].score += 1.5; // Бонус за стабильность
                    }
                }
            }

            // 3. СПЕЦИАЛЬНЫЙ БОНУС ЗА КЛАСТЕРНОЕ ПОВЕДЕНИЕ (без прямых ссылок на номера)
            // Анализируем, какие номера часто выпадали вместе в последние 50 тиражей
            console.log('🔍 АНАЛИЗ КЛАСТЕРНОГО ПОВЕДЕНИЯ...');
            const clusterBehaviorBonus = analyzeClusterBehavior(dataToUse);
            for (let i = 1; i <= 49; i++) {
                if (clusterBehaviorBonus[i]) {
                    numberScores[i].score += clusterBehaviorBonus[i];
                    console.log(`   • Номер ${i}: +${clusterBehaviorBonus[i].toFixed(1)} за кластерное поведение`);
                }
            }

            // Превращаем объект в массив и сортируем
            const sortedCandidates = Object.values(numberScores).sort((a, b) => b.score - a.score);

            // Возвращаем топ-10 номеров
            const top10 = sortedCandidates.slice(0, 10).map(c => c.number);
            
            console.log(`🧠 Смарт-цели (топ-10 по влиятельности): ${top10.join(', ')}`);
            return top10;
        }

        /**
         * Анализирует "жизненный цикл" номера, чтобы определить его текущую фазу.
         */
        function analyzeNumberLifecycle(num, dataToUse) {
            const numberData = dataToUse.number_data[num] || [];
            if (numberData.length < 5) return { phase: 'unknown', score: 0, debtRatio: 0, cv: 99 };

                    const { avgGap, cv } = calculateGapStats(numberData);
                const { debt } = calculateDebtIndicator(num);
            const { rsi } = calculateRSI(num);
            
            const debtRatio = avgGap > 0 ? debt / avgGap : 0;

            let phase = 'unknown';
            let score = 0;

            if (debtRatio > 2.0 && rsi < 35) {
                phase = 'Спящий';
                score = 25; // Снижен базовый балл
            } else if (debtRatio > 1.2 && rsi < 50) {
                phase = 'Пробуждается';
                score = 45; // Снижен балл
            } else if (debtRatio < 1.0 && rsi > 50 && rsi < 70) {
                phase = 'Горячий';
                score = 35; // Увеличен балл за горячую фазу
            } else if (debtRatio < 0.5 && rsi > 70) {
                phase = 'Остывает';
                score = 30; // Снижен балл
            } else {
                phase = 'Стабильный';
                score = 40; // Увеличен балл за стабильность
            }

            // Усиленные бонусы за стабильность и короткие паузы
            if (cv < 0.6) {
                score += 45; // Значительно увеличен бонус за высокую стабильность
            } else if (cv < 0.8) {
                score += 35; // Увеличен бонус за хорошую стабильность
            } else if (cv < 1.0) {
                score += 25; // Увеличен бонус за умеренную стабильность
            } else if (cv > 1.5) {
                score -= 25; // Увеличен штраф за хаос
            } else if (cv > 1.2) {
                score -= 15; // Добавлен штраф за высокую волатильность
            }

            // Усиленные бонусы за короткие паузы (кластерные номера имеют преимущество)
            if (debtRatio < 0.5) {
                score += 25; // Значительный бонус за очень короткие паузы
            } else if (debtRatio < 0.8) {
                score += 20; // Большой бонус за короткие паузы
            } else if (debtRatio < 1.0) {
                score += 10; // Бонус за нормальные паузы
            }

            return { phase, score, debtRatio, cv };
        }

        /**
         * Находит доминирующий структурный паттерн в последних N тиражах ("эпохе").
         */
        // АДАПТИВНЫЙ АНАЛИЗ ПОСЛЕДНИХ 2-3 ТИРАЖЕЙ
        function analyzeRecentPattern(analysisSize, dataToUse) {
            if (!dataToUse.draws || dataToUse.draws.length < analysisSize) {
                return { low: 2, mid: 2, high: 2, efficiency: 0, trend: 'unknown' };
            }

            const recentDraws = dataToUse.draws.slice(0, analysisSize);
            const RANGES = { low: { min: 1, max: 16 }, mid: { min: 17, max: 33 }, high: { min: 34, max: 49 } };

            let totalLow = 0, totalMid = 0, totalHigh = 0;
            let winningPatterns = 0;

            recentDraws.forEach(draw => {
                let low = 0, mid = 0, high = 0;
                draw.numbers.forEach(num => {
                    if (num >= RANGES.low.min && num <= RANGES.low.max) low++;
                    else if (num >= RANGES.mid.min && num <= RANGES.mid.max) mid++;
                    else high++;
                });
                totalLow += low;
                totalMid += mid;
                totalHigh += high;

                // Подсчитываем "выигрышные" паттерны (с минимум 3 совпадениями в 6 числах)
                if (low >= 2 || mid >= 2 || high >= 1) {
                    winningPatterns++;
                }
            });

            const efficiency = (winningPatterns / analysisSize) * 100;

            return {
                low: Math.round(totalLow / analysisSize),
                mid: Math.round(totalMid / analysisSize),
                high: Math.round(totalHigh / analysisSize),
                efficiency: efficiency,
                trend: efficiency > 70 ? 'very-good' : efficiency > 50 ? 'good' : efficiency > 30 ? 'moderate' : 'poor'
            };
        }

        // ГИБКИЕ ДИАПАЗОНЫ С УЧЕТОМ АДАПТИВНОГО АНАЛИЗА
        function getAdaptiveRanges(adaptivePattern, dataToUse) {
            const BASE_RANGES = {
                low: { min: 1, max: 16 },
                mid: { min: 17, max: 33 },
                high: { min: 34, max: 49 }
            };

            // Если средние числа доминируют в последних тиражах, расширяем диапазон средних
            if (adaptivePattern.mid >= 3) {
                return {
                    low: { min: 1, max: 15 },  // Уменьшаем низкие
                    mid: { min: 16, max: 35 }, // Расширяем средние
                    high: { min: 36, max: 49 } // Начинаем высокие позже
                };
            }

            // Если низкие числа доминируют, усиливаем их
            else if (adaptivePattern.low >= 3) {
                return {
                    low: { min: 1, max: 18 },  // Расширяем низкие
                    mid: { min: 19, max: 32 }, // Уменьшаем средние
                    high: { min: 33, max: 49 }
                };
            }

            // Стандартные диапазоны для сбалансированных паттернов
            return BASE_RANGES;
        }

        // ОРИГИНАЛЬНАЯ ФУНКЦИЯ ДЛЯ ДОЛГОСРОЧНОГО АНАЛИЗА
        function findDominantPattern(epochSize, dataToUse) {
            const RANGES = {
                low: { min: 1, max: 16 },
                mid: { min: 17, max: 33 },
                high: { min: 34, max: 49 }
            };
            const recentDraws = dataToUse.draws.slice(0, epochSize);
            const patternCounts = {};

            recentDraws.forEach(draw => {
                let low = 0, mid = 0, high = 0;
                draw.numbers.forEach(num => {
                    if (num >= RANGES.low.min && num <= RANGES.low.max) low++;
                    else if (num >= RANGES.mid.min && num <= RANGES.mid.max) mid++;
                    else high++;
                });
                const patternKey = `L${low}M${mid}H${high}`;
                patternCounts[patternKey] = (patternCounts[patternKey] || 0) + 1;
            });

            if (Object.keys(patternCounts).length === 0) {
                return { low: 2, mid: 2, high: 2 };
            }

            const dominantPatternKey = Object.keys(patternCounts).reduce((a, b) => patternCounts[a] > patternCounts[b] ? a : b);

            const match = dominantPatternKey.match(/L(\d+)M(\d+)H(\d+)/);
            return {
                low: parseInt(match[1], 10),
                mid: parseInt(match[2], 10),
                high: parseInt(match[3], 10)
            };
        }

        /**
         * Анализ волновых паттернов Эллиотта из v1.
         */
        function analyzeElliotWaves(number, data) {
            const numberData = data.number_data[number] || [];
            if (numberData.length < 15) return 0;

            const recentDrawNumbers = numberData.map(d => parseInt(d.draw_number)).slice(0, 15);
            let waveScore = 0;

            for (let i = 4; i < recentDrawNumbers.length; i++) {
                const window = recentDrawNumbers.slice(i - 4, i + 1);
                const trend = window[0] > window[4] ? -1 : 1;
                const hasCorrections = window.some((val, idx) => {
                    if (idx === 0 || idx === 4) return false;
                    return (trend > 0 && val < window[idx - 1]) || (trend < 0 && val > window[idx - 1]);
                });

                if (hasCorrections) waveScore += 1;
            }

            return Math.min(waveScore, 5);
        }


        /**
         * Финальная "Гибридная Консервативная Стратегия" v2.2.
         */
        function generateConservativeStrategy(numCombinations, customData = null) {
            const dataToUse = customData || lottoData;
            const EPOCH_SIZE = 100;
            const SMART_HISTORY_SIZE = 15;
            const RECENT_ANALYSIS_SIZE = 3; // Анализируем последние 2-3 тиража для адаптации

            console.log('================================================================');
            console.log('🚀 УЛУЧШЕННАЯ АДАПТИВНАЯ КОНСЕРВАТИВНАЯ СТРАТЕГИЯ (v3.0)');
            console.log('🎯 АДАПТИВНЫЙ АНАЛИЗ ПОСЛЕДНИХ 2-3 ТИРАЖЕЙ + ГИБКИЕ ПРАВИЛА');

            // 1. Получаем "умные" целевые номера (логика v2.2)
            const targetNumbers = getSmartTargetNumbers(SMART_HISTORY_SIZE, dataToUse);

            // 2. АДАПТИВНЫЙ АНАЛИЗ последних 2-3 тиражей
            console.log(`🎯 Адаптивный анализ: последние ${RECENT_ANALYSIS_SIZE} тиражей.`);
            const adaptivePattern = analyzeRecentPattern(RECENT_ANALYSIS_SIZE, dataToUse);
            console.log(`📊 Адаптивный паттерн: ${adaptivePattern.low}L-${adaptivePattern.mid}M-${adaptivePattern.high}H`);
            console.log(`📈 Тренд эффективности: ${adaptivePattern.efficiency.toFixed(1)}%`);

            // 3. ГИБКИЕ ДИАПАЗОНЫ с учетом адаптивного анализа
            const adaptiveRanges = getAdaptiveRanges(adaptivePattern, dataToUse);
            console.log(`🎪 Адаптивные диапазоны: ${adaptiveRanges.low.min}-${adaptiveRanges.low.max} (низкие), ${adaptiveRanges.mid.min}-${adaptiveRanges.mid.max} (средние)`);

            // 4. Анализируем "эпоху" для долгосрочного тренда (логика v2)
            console.log(`📚 Долгосрочный анализ: последние ${EPOCH_SIZE} тиражей.`);
            const dominantPattern = findDominantPattern(EPOCH_SIZE, dataToUse);
            console.log(`⚡ Доминирующий паттерн эпохи: ${dominantPattern.low}L-${dominantPattern.mid}M-${dominantPattern.high}H`);

            console.log('5. УЛУЧШЕННЫЙ СКОРИНГ НОМЕРОВ С АДАПТИВНЫМИ ПРАВИЛАМИ...');

            // 5. Оценить каждый номер на основе улучшенной логики
            const candidates = [];

            for (let num = 1; num <= 49; num++) {
                const lifecycle = analyzeNumberLifecycle(num, dataToUse);
                if (lifecycle.phase === 'unknown') continue;

                // Добавляем анализ Волн Эллиотта
                const waveScore = analyzeElliotWaves(num, dataToUse);
                lifecycle.score += waveScore * 3;

                // Добавляем бонус за корреляцию с "умными" целями
                if (targetNumbers.includes(num)) {
                    lifecycle.score += 40;
                }

                // АДАПТИВНЫЙ СКОРИНГ С УЧЕТОМ ДИАПАЗОНОВ
                let category = 'unknown';
                let adaptiveScore = 0;

                if (num >= adaptiveRanges.low.min && num <= adaptiveRanges.low.max) {
                    category = 'low';
                    adaptiveScore = 50; // Базовый бонус за низкие
                    if (lifecycle.phase === 'Пробуждается') adaptiveScore += 20;
                    if (lifecycle.phase === 'Горячий') adaptiveScore += 10;
                }
                else if (num >= adaptiveRanges.mid.min && num <= adaptiveRanges.mid.max) {
                    category = 'mid';
                    // ГИБКИЕ ПРАВИЛА ДЛЯ СРЕДНИХ ЧИСЕЛ!
                    if (adaptivePattern.mid >= 3 && adaptivePattern.efficiency > 50) {
                        // Если средние доминируют и эффективны - даем бонус
                        adaptiveScore = 30;
                        if (lifecycle.phase === 'Стабильный') adaptiveScore += 15;
                        if (lifecycle.phase === 'Горячий') adaptiveScore += 25;
                        if (lifecycle.phase === 'Пробуждается') adaptiveScore += 20;
                    } else {
                        // В остальных случаях - умеренный бонус или штраф
                        adaptiveScore = adaptivePattern.mid >= 2 ? 15 : -10;
                    }
                }
                else {
                    category = 'high';
                    adaptiveScore = 40; // Базовый бонус за высокие
                    if (lifecycle.phase === 'Горячий') adaptiveScore += 15;
                    if (lifecycle.phase === 'Остывает') adaptiveScore += 10;
                }

                const finalScore = lifecycle.score + adaptiveScore;

                candidates.push({
                    number: num,
                    score: finalScore,
                    phase: lifecycle.phase,
                    category: category,
                    cv: lifecycle.cv,
                    adaptiveBonus: adaptiveScore
                });
            }

            // 6. Разделить кандидатов на пулы по категориям и отсортировать по очкам
            const lowPool = candidates.filter(c => c.category === 'low').sort((a, b) => b.score - a.score);
            const midPool = candidates.filter(c => c.category === 'mid').sort((a, b) => b.score - a.score);
            const highPool = candidates.filter(c => c.category === 'high').sort((a, b) => b.score - a.score);

            console.log(`📊 Пулы кандидатов: ${lowPool.length} низких, ${midPool.length} средних, ${highPool.length} высоких.`);
            console.log('6. ГЕНЕРАЦИЯ КОМБИНАЦИЙ ПО АДАПТИВНОМУ ПАТТЕРНУ...');

            // 7. Сгенерировать комбинации, следуя АДАПТИВНОМУ паттерну
                const combinations = [];
            for (let i = 0; i < numCombinations; i++) {
                let combo = new Set();

                const pickFromPool = (pool, count) => {
                    if (count === 0 || pool.length === 0) return;

                    const shuffledPool = [...pool].sort(() => 0.5 - Math.random());
                    let picked = 0;
                    for (const candidate of shuffledPool) {
                        if (picked < count && !combo.has(candidate.number)) {
                            combo.add(candidate.number);
                            picked++;
                        }
                    }
                };

                // ИСПОЛЬЗУЕМ АДАПТИВНЫЙ ПАТТЕРН вместо доминирующего
                pickFromPool(lowPool, adaptivePattern.low);
                pickFromPool(midPool, adaptivePattern.mid);
                pickFromPool(highPool, adaptivePattern.high);

                // Если комбинация не полная, добираем из лучших кандидатов
                if (combo.size < 6) {
                    const allCandidates = [...lowPool, ...midPool, ...highPool].sort((a, b) => b.score - a.score);
                    for (const candidate of allCandidates) {
                        if (combo.size < 6 && !combo.has(candidate.number)) {
                            combo.add(candidate.number);
                        } else if (combo.size >= 6) {
                            break;
                        }
                    }
                }

                const finalCombo = Array.from(combo).sort((a, b) => a - b);
                if (finalCombo.length === 6) {
                    combinations.push(finalCombo);
                }
            }
            
            console.log(`✅ Сгенерировано ${combinations.length} финальных гибридных комбинаций.`);
            console.log('================================================================');
                return combinations;
        }

        // Сбалансированная стратегия - оптимальное сочетание
        function generateBalancedStrategy(numCombinations) {
            const candidates = [];

            // Оцениваем все номера по комплексным критериям
            for (let num = 1; num <= 49; num++) {
                const numberData = lottoData.number_data[num] || [];
                if (numberData.length < 3) continue;

                const trend = calculateNumberTrend(num);
                const { debt } = calculateDebtIndicator(num);
                const { avgGap, cv } = calculateGapStats(numberData);

                // Баланс между риском и потенциалом
                let score = 0;

                // Плюсы за недавнюю активность
                if (trend.status === 'hot' || trend.status === 'very-hot') score += 35; // Увеличен бонус
                else if (trend.status === 'cold') score += 25; // Увеличен бонус

                // Плюсы за короткие паузы (кластерные номера имеют преимущество)
                if (debt < 5) score += 30; // Бонус за очень короткие паузы
                else if (debt < 10) score += 20; // Бонус за короткие паузы
                else if (debt > 5 && debt < 20) score += 25; // Умеренный долг
                else if (debt > 20) score += 15; // Длинный долг

                // Усиленные плюсы за стабильность
                if (cv < 0.7) score += 35; // Высокая стабильность
                else if (cv < 1.0) score += 25; // Средняя стабильность
                else if (cv < 1.2) score += 15; // Умеренная стабильность

                // Усиленные минусы за слишком высокую волатильность
                if (cv > 1.5) score -= 25; // Хаотичный ритм
                else if (cv > 1.2) score -= 10; // Высокая волатильность

                if (score > 20) {
                    candidates.push({ number: num, score: score });
                }
            }

            candidates.sort((a, b) => b.score - a.score);
            const topNumbers = candidates.slice(0, 25).map(item => item.number);

            if (topNumbers.length < 6) {
                throw new Error('Недостаточно подходящих номеров');
            }

                const combinations = [];
            for (let i = 0; i < numCombinations; i++) {
                const combo = [];
                const shuffled = [...topNumbers].sort(() => Math.random() - 0.5);

                for (let j = 0; j < 6; j++) {
                    combo.push(shuffled[j]);
                }

                    combinations.push(combo.sort((a, b) => a - b));
                }

                return combinations;
        }

        // Агрессивная стратегия - максимальный риск
        function generateAggressiveStrategy(numCombinations) {
            const highRiskNumbers = [];

            // Ищем номера с максимальным потенциалом
            for (let num = 1; num <= 49; num++) {
                const numberData = lottoData.number_data[num] || [];
                if (numberData.length < 2) continue;

                const trend = calculateNumberTrend(num);
                const { debt } = calculateDebtIndicator(num);

                // Агрессивные критерии - максимальный риск (усилены для кластерных номеров)
                if ((trend.status === 'very-cold' || trend.status === 'cold') &&
                    debt > 10 && // Снижен порог паузы для более широкого охвата
                    numberData.length > 3) { // Снижен порог количества выпадений
                    highRiskNumbers.push(num);
                }
            }

            if (highRiskNumbers.length < 6) {
                // Если недостаточно холодных, добавляем горячие для баланса
                for (let num = 1; num <= 49; num++) {
                    const numberData = lottoData.number_data[num] || [];
                    if (numberData.length < 3) continue;

                    const trend = calculateNumberTrend(num);
                    if ((trend.status === 'very-hot' || trend.status === 'hot') &&
                        !highRiskNumbers.includes(num)) {
                        highRiskNumbers.push(num);
                    }
                }
            }

            if (highRiskNumbers.length < 6) {
                throw new Error('Недостаточно номеров для агрессивной стратегии');
            }

            const combinations = [];
            for (let i = 0; i < numCombinations; i++) {
                const combo = [];
                const shuffled = [...highRiskNumbers].sort(() => Math.random() - 0.5);

                for (let j = 0; j < 6; j++) {
                    combo.push(shuffled[j]);
                }

                combinations.push(combo.sort((a, b) => a - b));
            }

            return combinations;
        }

        // ИИ-стратегия с самообучением на основе полной статистики
        function generateAIStrategy(numCombinations) {
            console.log('================================================================');
            console.log('🤖 ИИ-СТРАТЕГИЯ С САМООБУЧЕНИЕМ');
            console.log('🧠 АНАЛИЗ ПОЛНОЙ СТАТИСТИКИ ДЛЯ ПРЕДСКАЗАНИЯ');

            // Получаем "умные" целевые номера (логика v2.2)
            const targetNumbers = getSmartTargetNumbers(15, lottoData);

            // Анализируем кластерное поведение
            const clusterBonuses = analyzeClusterBehavior(lottoData);

            // Анализируем тренды всех номеров
            const numberTrends = {};
            for (let i = 1; i <= 49; i++) {
                numberTrends[i] = calculateNumberTrend(i);
            }

            // Анализируем жизненные циклы всех номеров
            const numberLifecycles = {};
            for (let i = 1; i <= 49; i++) {
                numberLifecycles[i] = analyzeNumberLifecycle(i, lottoData);
            }

            // Создаем модель предсказания на основе комбинации факторов
            const aiScores = {};

            for (let i = 1; i <= 49; i++) {
                let score = 0;

                // 1. Базовый тренд
                const trend = numberTrends[i];
                if (trend.status === 'very-hot') score += 3.0;
                else if (trend.status === 'hot') score += 2.0;
                else if (trend.status === 'cold') score += 1.5;
                else if (trend.status === 'very-cold') score += 1.0;

                // 2. Жизненный цикл
                const lifecycle = numberLifecycles[i];
                if (lifecycle.phase === 'Горячий') score += 2.5;
                else if (lifecycle.phase === 'Пробуждается') score += 2.0;
                else if (lifecycle.phase === 'Стабильный') score += 1.5;
                else if (lifecycle.phase === 'Спящий') score += 1.0;

                // 3. Кластерные бонусы
                if (clusterBonuses[i]) score += clusterBonuses[i];

                // 4. "Умные" цели
                if (targetNumbers.includes(i)) score += 2.0;

                // 5. Волновые паттерны
                const waveScore = analyzeElliotWaves(i, lottoData);
                score += waveScore * 0.5;

                aiScores[i] = { score, number: i };
            }

            // Сортируем номера по ИИ-оценке
            const sortedByAI = Object.values(aiScores).sort((a, b) => b.score - a.score);

            // Выбираем топ-15 номеров для генерации комбинаций
            const topAINumbers = sortedByAI.slice(0, 15).map(item => item.number);

            console.log(`🎯 Топ-15 номеров по ИИ: ${topAINumbers.join(', ')}`);

            // Генерируем комбинации на основе ИИ-анализа
            const combinations = [];
            for (let i = 0; i < numCombinations; i++) {
                const combo = [];
                const shuffled = [...topAINumbers].sort(() => Math.random() - 0.5);

                for (let j = 0; j < 6; j++) {
                    combo.push(shuffled[j]);
                }

                combinations.push(combo.sort((a, b) => a - b));
            }

            console.log(`✅ Сгенерировано ${combinations.length} ИИ-комбинаций на основе полной статистики`);
            console.log('================================================================');

            return combinations;
        }

        // Отображение результатов стратегии
        function displayStrategyResults(combinations, title, realEfficiency = null, testCount = null) {
                const container = document.getElementById('generator-results-container');

                if (combinations.length === 0) {
                container.innerHTML = '<div class="error">Не удалось сгенерировать комбинации</div>';
                    return;
                }

                // Тестируем комбинации на количестве тиражей, указанном пользователем
                const userTestCount = parseInt(document.getElementById('testTirageCount').value, 10) || 20;
                const actualTestCount = Math.min(userTestCount, lottoData.draws.length);
                const testDraws = lottoData.draws.slice(0, actualTestCount);
                const winningResults = [];

                combinations.forEach((combo, comboIndex) => {
                    testDraws.forEach((draw, drawIndex) => {
                        const actualNumbers = new Set(draw.numbers);
                        const matchingNumbers = combo.filter(num => actualNumbers.has(num));
                        const matchCount = matchingNumbers.length;
                        if (matchCount >= 3) { // Минимум 3 совпадения = выигрыш
                            winningResults.push({
                                game: comboIndex + 1,
                                drawNumber: draw.draw_number,
                                date: draw.date,
                                matches: matchCount,
                                matchingNumbers: matchingNumbers,
                                combo: combo
                            });
                        }
                    });
                });

                // Группируем выигрыши по тиражам для отчета
                const drawsWithWins = {};
                winningResults.forEach(result => {
                    if (!drawsWithWins[result.drawNumber]) {
                        drawsWithWins[result.drawNumber] = {
                            date: result.date,
                            games: []
                        };
                    }
                    drawsWithWins[result.drawNumber].games.push({
                        game: result.game,
                        matches: result.matches,
                        matchingNumbers: result.matchingNumbers,
                        combo: result.combo
                    });
                });

                const titleHtml = `<h3 class="generator-results-title">${title} (${combinations.length} комб.)</h3>`;

                const gridHtml = combinations.map((combo, index) => {
                    const numbersHtml = combo.map(num => {
                        // Получаем тренд для цвета
                        const trend = calculateNumberTrend(num);
                        const trendClass = getTrendClass(trend.status);
                        return `<div class="combo-number ${trendClass}" onclick="selectNumberFromGenerator(${num})" title="Нажмите для анализа номера ${num}">${num}</div>`;
                    }).join('');

                return `<div class="combination-card">
                    <div class="combination-card-title">Игра ${index + 1}:</div>
                    <div class="combination-numbers">${numbersHtml}</div>
                </div>`;
                }).join('');

                container.innerHTML = `${titleHtml}<div class="combination-grid">${gridHtml}</div>`;

            // Генерируем HTML для информации о выигрышах
            let winningInfoHtml = '';
            if (Object.keys(drawsWithWins).length > 0) {
                winningInfoHtml = `
                    <div style="margin-top: 15px; padding: 15px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px;">
                        <h5 style="margin-top: 0; color: #155724;">🎯 Выигрыши найдены в тиражах:</h5>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 15px;">
                            ${Object.entries(drawsWithWins)
                                .sort((a, b) => b[0] - a[0]) // Сортировка от нового к старому
                                .map(([drawNum, info]) => `
                                <div style="padding: 12px; background: rgba(255,255,255,0.9); border-radius: 8px; border-left: 4px solid #28a745; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                    <div style="font-weight: 600; margin-bottom: 8px; color: #155724; font-size: 0.95em;">Тираж ${drawNum} (${info.date})</div>
                                    <div style="font-size: 0.9em; color: #333; line-height: 1.4;">
                                        ${info.games.map(game => `<div><strong>Игра ${game.game}:</strong> совпали ${game.matchingNumbers.join(', ')} <span style="color: #666;">(${game.matches} из 6)</span></div>`).join('')}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            } else {
                winningInfoHtml = `
                    <div style="margin-top: 15px; padding: 15px; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px;">
                        <h5 style="margin-top: 0; color: #721c24;">❌ Выигрыши не найдены</h5>
                        <p style="margin: 0;">В протестированных тиражах не найдено комбинаций с 3+ совпадениями</p>
                    </div>
                `;
            }

            // Добавляем краткую сводку
            let warningHtml = '';
            if (userTestCount > actualTestCount) {
                warningHtml = `
                    <div style="margin: 5px 0; padding: 5px 10px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; font-size: 12px; color: #856404;">
                        ⚠️ Запрошено ${userTestCount} тиражей, но доступно только ${actualTestCount}. Используются все доступные данные.
                    </div>
                `;
            }

            // Рассчитываем максимальное количество совпадений
            const maxMatches = winningResults.length > 0 ? Math.max(...winningResults.map(r => r.matches)) : 0;

            const summaryHtml = `
                <div class="quick-summary" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                    <h4 style="margin-top: 0; color: #333;">📊 Быстрая сводка</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                        <div style="padding: 10px; background: rgba(255,255,255,0.8); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.2em; font-weight: bold; color: var(--primary-color);">${combinations.length}</div>
                            <div style="font-size: 0.8em; color: #666;">Сгенерировано комбинаций</div>
                        </div>
                        <div style="padding: 10px; background: rgba(255,255,255,0.8); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.2em; font-weight: bold; color: ${winningResults.length > 0 ? '#28a745' : '#dc3545'};">${winningResults.length}</div>
                            <div style="font-size: 0.8em; color: #666;">Найдено выигрышей</div>
                        </div>
                        <div style="padding: 10px; background: rgba(255,255,255,0.8); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.2em; font-weight: bold; color: ${maxMatches >= 3 ? '#28a745' : '#dc3545'};">${maxMatches}</div>
                            <div style="font-size: 0.8em; color: #666;">Максимум совпадений</div>
                        </div>
                    </div>
                    <p style="margin: 5px 0;">• Средняя сумма: ${calculateAverageSum(combinations)}</p>
                    <p style="margin: 5px 0;">• Уникальных номеров: ${countUniqueNumbers(combinations)}</p>
                    <p style="margin: 5px 0;">• Протестировано тиражей: ${actualTestCount}</p>
                    ${warningHtml}
                    ${winningInfoHtml}
                </div>
            `;

            container.insertAdjacentHTML('beforeend', summaryHtml);
        }

        // Вспомогательные функции
        function calculateAverageSum(combinations) {
            const sums = combinations.map(combo => combo.reduce((a, b) => a + b, 0));
            const avg = sums.reduce((a, b) => a + b, 0) / sums.length;
            return Math.round(avg);
        }

        function countUniqueNumbers(combinations) {
            const allNumbers = new Set();
            combinations.forEach(combo => combo.forEach(num => allNumbers.add(num)));
            return allNumbers.size;
        }

        // Функция обновления быстрой сводки (глобальная)
        function updateQuickSummary() {
            const container = document.getElementById('generator-results-container');
            if (!container) return;

            // Ищем элемент быстрой сводки (по заголовку или по классу)
            let summaryElement = container.querySelector('.quick-summary');
            if (!summaryElement) {
                // Если не найден по классу, ищем по заголовку
                const headings = container.querySelectorAll('h4');
                for (let heading of headings) {
                    if (heading.textContent.includes('Быстрая сводка')) {
                        summaryElement = heading.parentElement;
                        break;
                    }
                }
            }
            if (!summaryElement) return;

            // Получаем текущие комбинации из DOM
            const combinationCards = container.querySelectorAll('.combination-card');
            if (combinationCards.length === 0) return;

            const combinations = [];
            combinationCards.forEach(card => {
                const numbers = [];
                const numberElements = card.querySelectorAll('.combo-number');
                numberElements.forEach(element => {
                    numbers.push(parseInt(element.textContent, 10));
                });
                if (numbers.length === 6) {
                    combinations.push(numbers);
                }
            });

            if (combinations.length === 0) return;

            // Пересчитываем анализ на новом количестве тиражей
            const userTestCount = parseInt(document.getElementById('testTirageCount').value, 10) || 20;
            const actualTestCount = Math.min(userTestCount, lottoData.draws.length);
            const testDraws = lottoData.draws.slice(0, actualTestCount);

            const winningResults = [];
                combinations.forEach((combo, comboIndex) => {
                    testDraws.forEach((draw, drawIndex) => {
                        const actualNumbers = new Set(draw.numbers);
                        const matchingNumbers = combo.filter(num => actualNumbers.has(num));
                        const matchCount = matchingNumbers.length;
                        if (matchCount >= 3) {
                            winningResults.push({
                                game: comboIndex + 1,
                                drawNumber: draw.draw_number,
                                date: draw.date,
                                matches: matchCount,
                                matchingNumbers: matchingNumbers,
                                combo: combo
                            });
                        }
                    });
                });

            // Группируем выигрыши по тиражам
            const drawsWithWins = {};
            winningResults.forEach(result => {
                if (!drawsWithWins[result.drawNumber]) {
                    drawsWithWins[result.drawNumber] = {
                        date: result.date,
                        games: []
                    };
                }
                drawsWithWins[result.drawNumber].games.push({
                    game: result.game,
                    matches: result.matches,
                    matchingNumbers: result.matchingNumbers,
                    combo: result.combo
                });
            });

            // Генерируем HTML для обновленной сводки
            let winningInfoHtml = '';
            if (Object.keys(drawsWithWins).length > 0) {
                // Сортируем результаты от новых к старым
                const sortedResults = Object.entries(drawsWithWins)
                    .sort((a, b) => b[0] - a[0]) // Сортировка от нового к старому
                    .flatMap(([drawNum, info]) => info.games.map(game => ({ drawNumber: drawNum, date: info.date, ...game })));

                // Разбиваем на группы по 3 результата для колонок
                const columns = [];
                for (let i = 0; i < sortedResults.length; i += 3) {
                    columns.push(sortedResults.slice(i, i + 3));
                }

                winningInfoHtml = `
                    <div style="margin-top: 15px; padding: 15px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px;">
                        <h5 style="margin-top: 0; color: #155724;">🎯 Выигрыши найдены в тиражах:</h5>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 15px;">
                            ${columns.map((columnResults, columnIndex) => `
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    ${columnResults.map(result => `
                                    <div style="padding: 12px; background: rgba(255,255,255,0.9); border-radius: 8px; border-left: 4px solid #28a745; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        <div style="font-weight: 600; margin-bottom: 8px; color: #155724; font-size: 0.95em;">Тираж ${result.drawNumber} (${result.date})</div>
                                        <div style="font-size: 0.9em; color: #333; line-height: 1.4;">
                                            <strong>Игра ${result.game}:</strong> совпали ${result.matchingNumbers.join(', ')}
                                            <span style="color: #666; margin-left: 8px;">(${result.matches} из 6)</span>
                                        </div>
                                    </div>
                                    `).join('')}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            } else {
                winningInfoHtml = `
                    <div style="margin-top: 15px; padding: 15px; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px;">
                        <h5 style="margin-top: 0; color: #721c24;">❌ Выигрыши не найдены</h5>
                        <p style="margin: 0;">В протестированных тиражах не найдено комбинаций с 3+ совпадениями</p>
                    </div>
                `;
            }

            // Обновляем содержимое быстрой сводки
            let warningHtml = '';
            if (userTestCount > actualTestCount) {
                warningHtml = `
                    <div style="margin: 5px 0; padding: 5px 10px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; font-size: 12px; color: #856404;">
                        ⚠️ Запрошено ${userTestCount} тиражей, но доступно только ${actualTestCount}. Используются все доступные данные.
                    </div>
                `;
            }

            // Рассчитываем максимальное количество совпадений
            const maxMatches = winningResults.length > 0 ? Math.max(...winningResults.map(r => r.matches)) : 0;

            const updatedSummaryHtml = `
                <div class="quick-summary" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                    <h4 style="margin-top: 0; color: #333;">📊 Быстрая сводка</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                        <div style="padding: 10px; background: rgba(255,255,255,0.8); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.2em; font-weight: bold; color: var(--primary-color);">${combinations.length}</div>
                            <div style="font-size: 0.8em; color: #666;">Сгенерировано комбинаций</div>
                        </div>
                        <div style="padding: 10px; background: rgba(255,255,255,0.8); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.2em; font-weight: bold; color: ${winningResults.length > 0 ? '#28a745' : '#dc3545'};">${winningResults.length}</div>
                            <div style="font-size: 0.8em; color: #666;">Найдено выигрышей</div>
                        </div>
                        <div style="padding: 10px; background: rgba(255,255,255,0.8); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.2em; font-weight: bold; color: ${maxMatches >= 3 ? '#28a745' : '#dc3545'};">${maxMatches}</div>
                            <div style="font-size: 0.8em; color: #666;">Максимум совпадений</div>
                        </div>
                    </div>
                    <p style="margin: 5px 0;">• Средняя сумма: ${calculateAverageSum(combinations)}</p>
                    <p style="margin: 5px 0;">• Уникальных номеров: ${countUniqueNumbers(combinations)}</p>
                    <p style="margin: 5px 0;">• Протестировано тиражей: ${actualTestCount}</p>
                    ${warningHtml}
                    ${winningInfoHtml}
                </div>
            `;

            // Заменяем содержимое быстрой сводки
            summaryElement.outerHTML = updatedSummaryHtml;
        }

        // Функция для проверки пользовательской комбинации
        function testCustomCombination() {
            const testCount = parseInt(document.getElementById('customTestTirageCount').value, 10) || 20;
            const container = document.getElementById('custom-results-container');

            // Собираем числа из отдельных полей
            const numbers = [];
            let hasEmptyFields = false;

            for (let i = 1; i <= 6; i++) {
                const numInput = document.getElementById(`customNum${i}`);
                const numValue = parseInt(numInput.value.trim());

                if (numInput.value.trim() === '' || isNaN(numValue)) {
                    hasEmptyFields = true;
                    numInput.style.borderColor = '#dc3545'; // Красная рамка для пустых полей
                } else {
                    numInput.style.borderColor = 'var(--bg-lighter)'; // Сброс рамки
                    if (numValue >= 1 && numValue <= 49) {
                        numbers.push(numValue);
                    } else {
                        numInput.style.borderColor = '#dc3545'; // Красная рамка для некорректных чисел
                        container.innerHTML = '<div class="error">Все числа должны быть от 1 до 49</div>';
                        return;
                    }
                }
            }

            if (hasEmptyFields) {
                container.innerHTML = '<div class="error">Заполните все 6 полей числами от 1 до 49</div>';
                return;
            }

            if (numbers.length !== 6) {
                container.innerHTML = '<div class="error">Введите ровно 6 чисел от 1 до 49</div>';
                return;
            }

            // Проверяем, что все числа уникальны
            const uniqueNumbers = [...new Set(numbers)];
            if (uniqueNumbers.length !== 6) {
                const duplicates = numbers.filter((num, index) => numbers.indexOf(num) !== index);
                const duplicateList = [...new Set(duplicates)].join(', ');
                container.innerHTML = `<div class="error">Найдены повторяющиеся числа: ${duplicateList}. В лотерее все числа в комбинации должны быть уникальными.</div>`;
                return;
            }

            const userTestCount = testCount;
            const actualTestCount = Math.min(userTestCount, lottoData.draws.length);

            if (lottoData.draws.length < actualTestCount) {
                container.innerHTML = '<div class="error">Недостаточно данных для тестирования</div>';
                return;
            }

            // Берем самые свежие тиражи для тестирования
            const testDraws = lottoData.draws.slice(0, actualTestCount);
            const winningResults = [];

            // Тестируем пользовательскую комбинацию
            testDraws.forEach((draw, drawIndex) => {
                const actualNumbers = new Set(draw.numbers);
                const matchingNumbers = numbers.filter(num => actualNumbers.has(num));
                const matchCount = matchingNumbers.length;

                if (matchCount >= 3) { // Минимум 3 совпадения = выигрыш
                    winningResults.push({
                        drawNumber: draw.draw_number,
                        date: draw.date,
                        matches: matchCount,
                        matchingNumbers: matchingNumbers,
                        combo: numbers
                    });
                }
            });

            // Отображаем результаты
            displayCustomCombinationResults([numbers], winningResults, actualTestCount);
        }

        // Отображение результатов проверки пользовательской комбинации
        function displayCustomCombinationResults(combinations, winningResults, testCount) {
            const container = document.getElementById('custom-results-container');

            const titleHtml = `<h3 class="generator-results-title">Результаты проверки вашей комбинации</h3>`;

            // Генерируем HTML для информации о выигрышах
            let winningInfoHtml = '';
            if (winningResults.length > 0) {
                // Сортируем результаты от новых к старым
                const sortedResults = winningResults.sort((a, b) => b.drawNumber - a.drawNumber);

                // Разбиваем на группы по 3 результата для колонок
                const columns = [];
                for (let i = 0; i < sortedResults.length; i += 3) {
                    columns.push(sortedResults.slice(i, i + 3));
                }

                winningInfoHtml = `
                    <div style="margin-top: 15px; padding: 15px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px;">
                        <h5 style="margin-top: 0; color: #155724;">🎯 Выигрыши найдены в тиражах:</h5>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 15px;">
                            ${columns.map((columnResults, columnIndex) => `
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    ${columnResults.map(result => `
                                    <div style="padding: 12px; background: rgba(255,255,255,0.9); border-radius: 8px; border-left: 4px solid #28a745; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        <div style="font-weight: 600; margin-bottom: 8px; color: #155724; font-size: 0.95em;">Тираж ${result.drawNumber} (${result.date})</div>
                                        <div style="font-size: 0.9em; color: #333; line-height: 1.4;">
                                            <strong>Совпали:</strong> ${result.matchingNumbers.join(', ')}
                                            <span style="color: #666; margin-left: 8px;">(${result.matches} из 6)</span>
                                        </div>
                                    </div>
                                    `).join('')}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            } else {
                winningInfoHtml = `
                    <div style="margin-top: 15px; padding: 15px; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px;">
                        <h5 style="margin-top: 0; color: #721c24;">❌ Выигрыши не найдены</h5>
                        <p style="margin: 0;">В проверенных ${testCount} тиражах не найдено 3+ совпадений</p>
                    </div>
                `;
            }

            // Добавляем краткую сводку
            const maxMatches = winningResults.length > 0 ? Math.max(...winningResults.map(r => r.matches)) : 0;
            const summaryHtml = `
                <div class="quick-summary" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                    <h4 style="margin-top: 0; color: #333;">📊 Результаты проверки</h4>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 15px;">
                        <div style="padding: 10px; background: rgba(255,255,255,0.8); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.2em; font-weight: bold; color: var(--primary-color);">${testCount}</div>
                            <div style="font-size: 0.8em; color: #666;">Проверено тиражей</div>
                        </div>
                        <div style="padding: 10px; background: rgba(255,255,255,0.8); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.2em; font-weight: bold; color: ${maxMatches >= 3 ? '#28a745' : '#dc3545'};">${maxMatches}</div>
                            <div style="font-size: 0.8em; color: #666;">Максимум совпадений</div>
                        </div>
                    </div>
                    <p style="margin: 5px 0; text-align: center; font-weight: 600;">• Найдено выигрышей: ${winningResults.length}</p>
                    ${winningInfoHtml}
                </div>
            `;

            container.innerHTML = `${titleHtml}${summaryHtml}`;
        }
    </script>
</body>
</html>